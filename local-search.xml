<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>8086CPU寄存器</title>
    <link href="/2022/01/15/blog/Asm/8086%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <url>/2022/01/15/blog/Asm/8086%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="8086CPU寄存器"><a href="#8086CPU寄存器" class="headerlink" title="8086CPU寄存器"></a>8086CPU寄存器</h1><p>8086CPU共有14个寄存器，分别是AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。所有的寄存器都是16位的。</p><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>AX、BX、CX、DX这4个寄存器通常用来存放一般性数据，称为<code>通用寄存器</code>。这4个寄存器可以分为两个独立的8位寄存器来使用。例如AX可以分为AH和AL。AH为<strong>高8位</strong>，AL为<strong>低8位</strong>。</p><h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><p>8086CPU的地址总线有20位，它通过两个16位的寄存器来寻址。一个寄存器存储<code>段地址</code>，叫做<code>段寄存器</code>，另一个寄存器存储<code>偏移地址</code>。物理地址=段地址x16+偏移地址。由<code>地址加法器</code>将两个16位地址合成为一个20位的物理地址。</p><p>段寄存器有4个：<code>CS</code>、<code>DS</code>、<code>SS</code>、<code>ES</code>。</p><h2 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h2><p>CS和IP两个寄存器指示了CPU当前要读取指令的地址。CS为<code>代码段寄存器</code>、IP为<code>指令指针寄存器</code>。8086CPU将从CSx16+IP处读取下一条指令。当CPU读取完一条指令后，IP=IP+所读取指令的长度，从而指向下一条指令。</p><p>当8086CPU加电启动或复位后，CS被设置为<code>FFFFH</code>，IP被设置为<code>0000H</code>。所以8086CPU启动后执行的第一条指令地址为<code>FFFF0H</code></p><p>CS和IP的值不能使用mov指令修改，而是使用转移指令来修改，例如<code>jmp</code>。</p><h2 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h2><p><code>DS寄存器</code>通常用来存放要访问数据的段地址。通过<code>[address]</code>指定数据的偏移地址。例如，访问10000H单元的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov bx, 1000H<br>mov ds, bx<br>mov al, [0]<br></code></pre></td></tr></table></figure><p>8086CPU不支持将数据直接送入段寄存器的操作。要将数据送入DS需要先将数据送入一般的寄存器，然后再送入DS寄存器。</p><h2 id="SS和SP寄存器"><a href="#SS和SP寄存器" class="headerlink" title="SS和SP寄存器"></a>SS和SP寄存器</h2><p>8086CPU提供了栈机制。通过<code>PUSH</code>指令可以将数据从寄存器压入栈中，通过<code>POP</code>指令可以将栈顶的数据弹出到寄存器中。入栈和出栈都是以字为单位的。</p><p>栈顶的地址由<code>SS</code>和<code>SP</code>表示。SS存储段地址、SP存储偏移地址。SSx16+SP就是当前栈顶元素的物理地址。当执行PUSH指令时，先将SP-2，然后将数据送入CS:IP处。POP命令则相反。</p><p>PUSH和POP指令的操作数可以是<code>寄存器</code>、<code>段寄存器</code>或内存单元。</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《汇编语言（第四版）》王爽</li></ol>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang学习笔记（一）</title>
    <link href="/2021/11/06/blog/Golang/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/11/06/blog/Golang/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang学习笔记（一）"><a href="#Golang学习笔记（一）" class="headerlink" title="Golang学习笔记（一）"></a>Golang学习笔记（一）</h1><h2 id="一、Golang简介"><a href="#一、Golang简介" class="headerlink" title="一、Golang简介"></a>一、Golang简介</h2><p><code>Go语言</code>(<em>又称Golang</em>)是由<strong>Google</strong>开发的一种<strong>静态强类型</strong>、<strong>编译型</strong>、<strong>并发型</strong>的具有<strong>垃圾回收功能</strong>的<strong>编程语言</strong>。</p><h2 id="二、Golang的基本语法"><a href="#二、Golang的基本语法" class="headerlink" title="二、Golang的基本语法"></a>二、Golang的基本语法</h2><h3 id="1-名称"><a href="#1-名称" class="headerlink" title="1.名称"></a>1.名称</h3><p>Golang中变量、常量、类型、函数、语句标签和包的名称遵循以下规则：</p><ol><li>以Unicode字符或下划线开头；</li><li>首个字符后面可以跟任意数量的字符、数字和下划线；</li><li>区分大小写；</li><li>不能与Golang中的关键字相同；</li><li>可以与内置的预声明变量、类型和函数相同，但是不建议这么做；</li><li>包名本身由小写字符组成；</li><li>Golang中的名称一般使用驼峰式命名，首字母缩略词通常使用相同的大小写。</li></ol><h3 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2.作用域"></a>2.作用域</h3><ol><li>在函数中声明的实体只在函数的局部有效；</li><li>声明在函数外的实体对包内的所有源文件可见；</li><li>如果实体的名称以大写字母开头，则它可以被包外的程序引用；如果以小写字母开头，则对包外不可见。</li></ol><h3 id="3-声明"><a href="#3-声明" class="headerlink" title="3.声明"></a>3.声明</h3><p>Golang中的声明主要有四种：</p><ol><li>变量(var)</li><li>常量(const)</li><li>类型(type)</li><li>函数(func)</li></ol><p>Golang的源代码存储在一个或多个以<code>.go</code>为后缀的文件中。每个未见以<code>package</code>声明开头，表明文件属于哪一个包。后面是<code>import</code>声明，然后是包级别的类型、变量、常量、函数的声明。</p><p>函数的成名包含一个名字、一个参数列表、一个可选的返回值列表以及函数体。格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> &lt;函数名&gt;<span class="hljs-params">(&lt;参数列表&gt;)</span> [返回值类型]</span> &#123;<br>    <span class="hljs-comment">// 函数体</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-变量"><a href="#4-变量" class="headerlink" title="4.变量"></a>4.变量</h3><p>Golang中使用<code>var</code>关键字声明变量。通用格式为：</p><p>var name type = expression</p><p>如果省略变量的类型，编译器会通过表达式推断变量的类型。如果省略表达式，变量将会被初始化为该类型的零值。</p><table><thead><tr><th align="center">类型</th><th align="center">零值</th></tr></thead><tbody><tr><td align="center">数字</td><td align="center">0</td></tr><tr><td align="center">布尔值</td><td align="center">false</td></tr><tr><td align="center">字符串</td><td align="center">“”</td></tr><tr><td align="center">接口和引用类型</td><td align="center">nil</td></tr></tbody></table><p>对于像数组和结构体这样的复合类型，零值是其所有元素或成员的零值。</p><p>可以声明一个变量列表并使用对应的表达式列表对其初始化。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i, j, k <span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> b, f, s = <span class="hljs-literal">true</span>, <span class="hljs-number">2.3</span>, <span class="hljs-string">&quot;four&quot;</span><br></code></pre></td></tr></table></figure><p>变量可以通过调用返回多个值的函数进行初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f, err = os.Open(name)<br></code></pre></td></tr></table></figure><h4 id="1-短变量声明"><a href="#1-短变量声明" class="headerlink" title="(1) 短变量声明"></a>(1) 短变量声明</h4><p>Golang中短变量声明的形式为：</p><p>name:= expression</p><p>编译器通过表达式推断变量的类型。</p><p>可以使用短变量类型声明多个变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">i, j := <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>f, err := os.Open(name)<br></code></pre></td></tr></table></figure><p>短变量声明不需要声明所有在左边的变量。如果一些变量在同一个词法块中声明，则短声明的行为相当于赋值。短变量声明至少声明一个变量。</p><h4 id="2-指针"><a href="#2-指针" class="headerlink" title="(2) 指针"></a>(2) 指针</h4><ol><li>指针的值是一个变量的地址，所有的变量都有地址。</li><li>使用取地址符(<code>&amp;</code>)可以获取变量的地址。使用<code>*</code>可以对指针进行解引用。</li><li>每一个聚合类型变量都由变量组成，所以也有地址。</li><li>代表变量的表达式是唯一可以应用取地址符的表达式。</li><li>指针的零值是<code>nil</code>。</li><li>函数可以返回局部变量的地址。</li></ol><h4 id="3-new函数"><a href="#3-new函数" class="headerlink" title="(3) new函数"></a>(3) new函数</h4><p><code>new函数</code>用于创建变量。表达式**new(T)**可以创建一个未命名的T类型的变量，初始化为T类型的零值并返回其地址。</p><h4 id="4-变量的生命周期"><a href="#4-变量的生命周期" class="headerlink" title="(4) 变量的生命周期"></a>(4) 变量的生命周期</h4><p>包级别变量的声明周期是整个程序的执行时间。局部变量在每次执行声明语句是时创建一个新的变量，该变量一直生存到它变得不可访问。变量在堆或栈上是由编译器来决定的，不是有var或new决定的。</p><h3 id="4-赋值"><a href="#4-赋值" class="headerlink" title="4.赋值"></a>4.赋值</h3><h4 id="1-多重赋值"><a href="#1-多重赋值" class="headerlink" title="(1) 多重赋值"></a>(1) 多重赋值</h4><p>使用多重赋值可以一次性赋值多个变量。在赋值前<code>=</code>右侧的所有表达式都会被计算。可以将不需要的值付给空标识符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">_, err = io.Copy(dst, src)<br></code></pre></td></tr></table></figure><h3 id="5-类型声明"><a href="#5-类型声明" class="headerlink" title="5.类型声明"></a>5.类型声明</h3><p>使用type声明可以定义一个新的命名类型，它与某个已有的类型使用相同的底层类型。通用格式为：</p><p>type name underlying-type</p><h2 id="三、Golang中的基本数据类型"><a href="#三、Golang中的基本数据类型" class="headerlink" title="三、Golang中的基本数据类型"></a>三、Golang中的基本数据类型</h2><p>Golang的数据类型分为四大类：</p><table><thead><tr><th align="center">类型分类</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center">基本类型</td><td align="center">数字、字符串、布尔型</td></tr><tr><td align="center">聚合类型</td><td align="center">数组、结构体</td></tr><tr><td align="center">引用类型</td><td align="center">指针、slice、map、函数、通道</td></tr><tr><td align="center">接口类型</td><td align="center">接口</td></tr></tbody></table><h3 id="1-整数"><a href="#1-整数" class="headerlink" title="1.整数"></a>1.整数</h3><p>Golang同时具有有符号整数和无符号整数。</p><p>有符号整数：</p><table><thead><tr><th align="center">类型</th><th align="center">大小</th></tr></thead><tbody><tr><td align="center">int8</td><td align="center">8</td></tr><tr><td align="center">int16</td><td align="center">16</td></tr><tr><td align="center">int32</td><td align="center">32</td></tr><tr><td align="center">int64</td><td align="center">64</td></tr></tbody></table><p>无符号整数：</p><table><thead><tr><th align="center">类型</th><th align="center">大小</th></tr></thead><tbody><tr><td align="center">uint8</td><td align="center">8</td></tr><tr><td align="center">uint16</td><td align="center">16</td></tr><tr><td align="center">uint32</td><td align="center">32</td></tr><tr><td align="center">uint64</td><td align="center">64</td></tr></tbody></table><p>除了上述8种类型外，Golang中还有<code>int</code>和<code>uint</code>两种类型，它们与原生的有\无符号整数相同，或者在该平台上的运算效率最高。</p><p><code>rune</code>类型是int32的同义词，常常用于表示Unicode码点。<code>byte</code>类型是uint8的同义词。</p><p>无符号整数类型<code>uintptr</code>的大小不明确，但是足以存放指针。</p><p>n位有符号整数的表示范围是-2^(n-1)<del>2^(n-1)-1。n位无符号类型的表示范围是0</del>2^n-1。</p><p>Golang中的二元运算符按优先级降序排序如下：</p><p><code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>&amp;^</code><br><code>+</code>, <code>-</code>, <code>|</code>, <code>^</code><br><code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code><br><code>&amp;&amp;</code><br><code>||</code></p><h3 id="2-浮点数"><a href="#2-浮点数" class="headerlink" title="2.浮点数"></a>2.浮点数</h3><p>Golang中有两种大小的浮点数float32和float64。</p><p>math包中的的MaxFloat32是float32的最大值。math.MaxFloat64是float64的最大值。最小值类似。</p><p>math.IsNaN用于判断参数是否是非数值。</p><h3 id="3-复数"><a href="#3-复数" class="headerlink" title="3.复数"></a>3.复数</h3><p>Golang中的复数类型为complex64和complex128，分别由float32和float64组成。内置函数complex可用于创建复数，real函数和imag函数可用于提取复数的实部和虚部：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-keyword">complex128</span> = <span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>fmt.Println(<span class="hljs-built_in">real</span>(x))<br>fmt.Println(<span class="hljs-built_in">imag</span>(x))<br></code></pre></td></tr></table></figure><h3 id="4-布尔值"><a href="#4-布尔值" class="headerlink" title="4.布尔值"></a>4.布尔值</h3><p><code>bool型</code>的值只有两种可能：true和false。<code>!</code>表示取反。<code>&amp;&amp;</code>和<code>||</code>分别表示与运算和或运算，它们都有可能引起短路行为，&amp;&amp;的优先级比||高。bool类型与数值类型不能隐式转换。</p><h3 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5.字符串"></a>5.字符串</h3><p>在Golang中，字符串是不可变的字符序列，可以包含任意数据。len函数可以获取字符串的字节数。</p><p>子串生成操作<code>s[i:j]</code>产生新的字符串。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> str <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;hello world&quot;</span><br>fmt.Println(str[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>])<br></code></pre></td></tr></table></figure><p>可以使用<code>+</code>连接两个字符串生成一个新的字符串。</p><p>字符串本身可以做比较，比较按字节进行，符合字典排序。</p><h4 id="1-字符串字面量"><a href="#1-字符串字面量" class="headerlink" title="(1) 字符串字面量"></a>(1) 字符串字面量</h4><p>使用带双引号的字节序列表示字符串字面量。一般字符串按utf-8进行编码。字符串中可以有转义序列，以<code>\</code>开始：</p><table><thead><tr><th align="center">转义序列</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">\a</td><td align="center">警告或响铃</td></tr><tr><td align="center">\b</td><td align="center">退格</td></tr><tr><td align="center">\f</td><td align="center">换页</td></tr><tr><td align="center">\n</td><td align="center">换行</td></tr><tr><td align="center">\r</td><td align="center">回车</td></tr><tr><td align="center">\t</td><td align="center">水平制表符</td></tr><tr><td align="center">\v</td><td align="center">垂直制表符</td></tr><tr><td align="center">&#39;</td><td align="center">单引号</td></tr><tr><td align="center">&quot;</td><td align="center">双引号</td></tr><tr><td align="center">\</td><td align="center">反斜杠</td></tr><tr><td align="center">\xhh</td><td align="center">十六进制字节</td></tr><tr><td align="center">\ooo</td><td align="center">八进制字节</td></tr><tr><td align="center">\uhhhh</td><td align="center">16位码点</td></tr><tr><td align="center">\uhhhhhhhh</td><td align="center">32位码点</td></tr></tbody></table><p>使用反引号表示原生的字符串字面量，转义序列不起作用。</p><h4 id="2-字符串和字节slice"><a href="#2-字符串和字节slice" class="headerlink" title="(2) 字符串和字节slice"></a>(2) 字符串和字节slice</h4><p><code>bytes</code>、<code>strings</code>、<code>strconv</code>、<code>unicode</code>4个标准包用于支持对字符串的操作。</p><p>strings包提供了用于搜索、替换、比较、修整、切分和连接字符串的函数。</p><p>bytes包中具有用于操作字节slice的函数。</p><p>strconv包提供了转换布尔值、整数、浮点数为与之对应的字符串形式以及进行相反操作的函数。</p><p>unicode包提供了用于判别文字符号值的特性的函数。</p><h3 id="6-常量"><a href="#6-常量" class="headerlink" title="6.常量"></a>6.常量</h3><p>Golang中使用<code>const</code>声明常量，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.14</span><br></code></pre></td></tr></table></figure><p>可以指定常量的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> pi <span class="hljs-keyword">float64</span> = <span class="hljs-number">3.14</span><br></code></pre></td></tr></table></figure><p>可以同时声明多个常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>e = <span class="hljs-number">2.718</span><br>    pi = <span class="hljs-number">3.14</span><br>)<br></code></pre></td></tr></table></figure><h4 id="1-常量生成器iota"><a href="#1-常量生成器iota" class="headerlink" title="(1) 常量生成器iota"></a>(1) 常量生成器iota</h4><p>iota创建一系列相关值，而不是逐个值显式写出。常量声明中，iota从0开始取值，逐项加一，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Weekday <span class="hljs-keyword">int</span><br><br><span class="hljs-keyword">const</span> (<br>Sunday Weekday = itoa<br>    Monday<br>    Tuesday<br>    Wednesday<br>    Thursday<br>    Friday<br>    Saturday<br>)<br></code></pre></td></tr></table></figure><p>更复杂的表达式也可以使用iota</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Flags <span class="hljs-keyword">uint</span><br><br><span class="hljs-keyword">const</span> (<br>FlagUp Flags = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span><br>    FlagBroadcast<br>    FlagLoopback<br>    FlagPointToPoint<br>    FlagMuticast<br>)<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《Go程序设计语言》</li><li><a href="https://zh.wikipedia.org/wiki/Go">Go —— 维基百科</a></li><li><a href="http://c.biancheng.net/golang/">Go语言入门教程</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB Arena源码分析</title>
    <link href="/2021/10/23/blog/Database/LevelDB-Arena%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2021/10/23/blog/Database/LevelDB-Arena%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="LevelDB-Arena源码分析"><a href="#LevelDB-Arena源码分析" class="headerlink" title="LevelDB Arena源码分析"></a>LevelDB Arena源码分析</h1><h2 id="什么是Arena"><a href="#什么是Arena" class="headerlink" title="什么是Arena"></a>什么是Arena</h2><p><code>Arena</code>是<code>LevelDB</code>中实现的一个简易的<code>内存池</code>。因为LevelDB是一个<code>key-value数据库</code>，所以当为较小的key或value分配内存时可能会引起<code>内存碎片</code>以及<code>性能问题</code>（频繁调用new和delete）。Arena就是为了解决这些问题的。Arena的实现非常简洁，不过100多行C++代码，十分适合学习。下面我们就一起了解一下Google大佬们管理内存的方法吧。</p><h2 id="Arena的实现思路"><a href="#Arena的实现思路" class="headerlink" title="Arena的实现思路"></a>Arena的实现思路</h2><p>既然分配较小的内存会导致产生内存碎片，那么我们可以先分配一块较大的内存块，然后在将这个内存块分割成若干个较小的内存块分配给使用者来存储较小的key或value，这就是Arena的基本思路。</p><p>首先我们来看一下Arena的几个成员变量，它们指示了Arena当前的状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">char</span>* alloc_ptr_; <span class="hljs-comment">// 内存块未分配内存的起始地址</span><br><span class="hljs-keyword">size_t</span> alloc_bytes_remaining_; <span class="hljs-comment">// 内存块中未分配的字节数</span><br>std::vector&lt;<span class="hljs-keyword">char</span>*&gt; blocks_; <span class="hljs-comment">// Arena已申请的内存块</span><br>std::atomic&lt;<span class="hljs-keyword">size_t</span>&gt; memory_usage_; <span class="hljs-comment">// Arena的内存使用量</span><br></code></pre></td></tr></table></figure><p>来看下面一张图：</p><p><img src="/myresource/img/arena.png" alt="Arena内存分配原理"></p><p>Arena的<code>blocks_</code>成员存储着Arena已经申请的内存块。<code>alloc_ptr_</code>指向当前内存块中尚未分配空间的起始地址。当需要Arena分配n个字节的内存时，如果n大于1024（也就是1KB），则Arena会申请一个大小为n的内存块并返回内存块的地址，<code>alloc_ptr_</code>和<code>alloc_bytes_remaining_</code>的值都不会改变（之所以这样做是为了避免浪费大量内存）。如果n小于1024并且当前块中的内存块中剩余的字节数大于或等于n，那么Arena会以<code>alloc_ptr_</code>为起始地址分配n个字节的内存返回给申请者，并将<code>alloc_ptr_</code>向后移动n个字节指向新的未分配空间的起始地址。如果内存块剩余的空间小于n，则Arena会申请新的一块大小为4KB的内存块给调用者分配内存，之前的内存块中尚未分配的内存就浪费了。所以Arena最多会浪费1/4的内存。</p><h2 id="Arena的实现"><a href="#Arena的实现" class="headerlink" title="Arena的实现"></a>Arena的实现</h2><p>Arena为使用者提供了三个成员函数接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">Allocate</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> bytes)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">AllocateAligned</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> bytes)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">MemoryUsage</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> memory_usage_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Allocate</code>用于为调用者分配bytes个字节的内存，<code>AllocateAligned</code>则为调用者分配bytes个字节的对齐的内存，<code>MemoryUsage</code>用于查看该Arena对象使用的内存总量。我们重点看一下<code>Allocate</code>和<code>AllocateAligned</code>的实现：</p><h3 id="Allocate的实现"><a href="#Allocate的实现" class="headerlink" title="Allocate的实现"></a>Allocate的实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">Arena::Allocate</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> bytes)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(bytes &gt; <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (bytes &lt;= alloc_bytes_remaining_) &#123;<br>        <span class="hljs-keyword">char</span>* result = alloc_ptr_;<br>        alloc_ptr_ += bytes;<br>        alloc_bytes_remaining_ -= bytes;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">AllocateFallback</span>(bytes);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Allocate</code>首先会判断一下当前块中剩余的空间是否足够分配bytes个字节的内存。如果空间足够，Allocate会将<code>alloc_ptr_</code>向后移动bytes个字节让其指向新的未分配的内存的起始地址，并将<code>alloc_bytes_remaining_</code>减小bytes，然后返回分配的内存。如果当前块的剩余空间不足以分配bytes字节的内存，则Allocate会调用<code>AllocateFallback</code>申请新的内存块分配内存。下面是<code>AllocateFallback</code>的源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">Arena::AllocateFallback</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> bytes)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (bytes &gt; kBlockSize / <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-keyword">char</span>* result = <span class="hljs-built_in">AllocateNewBlock</span>(bytes);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    alloc_ptr_ = <span class="hljs-built_in">AllocateNewBlock</span>(kBlockSize);<br>    alloc_bytes_remaining_ = kBlockSize;<br><br>    <span class="hljs-keyword">char</span>* result = alloc_ptr_;<br>    alloc_ptr_ += bytes;<br>    alloc_bytes_remaining_ -= bytes;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>AllocateFallback</code>用于为Arena申请新的内存块。首先，AllocateFallback会判断bytes是否大于1024。如果大于1024，AllocateFallback会调用<code>AllocateNewBlock</code>申请一个大小为bytes的内存块并返回，Arena会继续使用当前内存块进行下一次的内存分配。弱国小于或等于1024，则AllocateFallback会调用AllocateNewBlock申请一个大小为4KB的内存块并在新的内存块上分配内存。原来的内存块中未分配的空间则被浪费。</p><p>我们再来看一下<code>AllocateNewBlock</code>的源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">Arena::AllocateNewBlock</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> block_bytes)</span> </span>&#123;<br>    <span class="hljs-keyword">char</span>* result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[block_bytes];<br>    blocks_.<span class="hljs-built_in">push_back</span>(result);<br>    memory_usage_.<span class="hljs-built_in">fetch_add</span>(block_bytes + <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">char</span>*),<br>                            std::memory_order_relaxed);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>AllocateNewBlock的代码很简单，它首先使用<code>new[]</code>申请<code>block_bytes</code>个字节的内存，然后将这个内存块加入<code>block_</code>中（Arena在析构时会释放掉block_中所有的内存），再记录一下内存的使用量就可以了。</p><h2 id="AllocateAligned的实现"><a href="#AllocateAligned的实现" class="headerlink" title="AllocateAligned的实现"></a>AllocateAligned的实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">Arena::AllocateAligned</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> bytes)</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> align = (<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">void</span>*) &gt; <span class="hljs-number">8</span>) ? <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">void</span>*) : <span class="hljs-number">8</span>;<br>    <span class="hljs-built_in"><span class="hljs-keyword">static_assert</span></span>((align &amp; (align - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>,<br>                    <span class="hljs-string">&quot;Pointer size should be a power of 2&quot;</span>);<br>    <span class="hljs-keyword">size_t</span> current_mod = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uintptr_t</span>&gt;(alloc_ptr_) &amp; (align - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">size_t</span> slop = (current_mod == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : align - current_mod);<br>    <span class="hljs-keyword">size_t</span> needed = bytes + slop;<br>    <span class="hljs-keyword">char</span>* result;<br>    <span class="hljs-keyword">if</span> (needed &lt;= alloc_bytes_remaining_) &#123;<br>        result = alloc_ptr_ + slop;<br>        alloc_ptr_ += needed;<br>        alloc_bytes_remaining_ -= needed;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        result = <span class="hljs-built_in">AllocateFallback</span>(bytes);<br>    &#125;<br>    <span class="hljs-built_in">assert</span>((<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uintptr_t</span>&gt;(result) &amp; (align - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>AllocateAligned</code>以sizeof(void*)对齐内存（如果sizeof(void*)大于8的话），所以在64位机上它使用8字节对齐。变量<code>slop</code>的值是对齐到8个字节所需要的字节数。slop加上bytes就是分配这段内存所需要的字节数。接下来的流程就跟<code>Allocate</code>一样了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Arena的主要内容基本上就分析完了。虽然Arena的设计简单，却又十分巧妙，成功解决了内存碎片以及频繁调用new和delete的问题。博主接下来的一个小项目需要内存池来分配空间存储一些小的字符串，正好可以实现一个类似于Arena的内存池试试效果。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://github.com/google/leveldb">LevelDB Github仓库</a></li><li><a href="http://kaiyuan.me/2017/05/02/leveldb-03/">leveldb 笔记三：Arena 内存管理</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据库</tag>
      
      <tag>LevelDB</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python的几个知识点</title>
    <link href="/2021/10/20/blog/Python/Python%E7%9A%84%E5%87%A0%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2021/10/20/blog/Python/Python%E7%9A%84%E5%87%A0%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Python的几个知识点"><a href="#Python的几个知识点" class="headerlink" title="Python的几个知识点"></a>Python的几个知识点</h1><p>最近博主学到了几个Python中比较重要的几个知识点，写篇博客记录一下。</p><h2 id="和is的区别"><a href="#和is的区别" class="headerlink" title="==和is的区别"></a>==和is的区别</h2><p>虽然之前大概知道<code>==</code>和<code>is</code>的区别，但是一直感觉模模糊糊，今天写代码的时候恰巧遇到了这个问题，就去查了一些资料，明确了一下。</p><p><code>==</code>运算符用与判断两个变量所引用的对象的值是否相等，<code>is</code>则是判断两个变量引用的是否是同一个对象。假设v1、v2是两个引用可变对象的变量，如果v2是由v1浅拷贝得到的(或者是赋值得到的)，那么v1和v2引用的是同一个可变对象，所以<code>v1 == v2</code>和<code>v1 is v2</code>都返回<code>True</code>；如果v2是由v1深拷贝得到的，则v1和v2引用的是不同的可变对象，所以<code>v1 == v2</code>返回<code>True</code>，<code>v1 is v2</code>返回<code>False</code>。对于不可变对象，由于Python可能会进行优化，有时即使使用deepcopy进行深拷贝，Python也会让变量指向同一个对象，所以<code>v1 is v2</code>可能返回<code>True</code>。</p><h2 id="判断对象是否是可迭代对象"><a href="#判断对象是否是可迭代对象" class="headerlink" title="判断对象是否是可迭代对象"></a>判断对象是否是可迭代对象</h2><p>在Python中判断对象是否<code>可迭代</code>的方法是判断该对象是否是<code>Iterable</code>的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>, Iterable)) <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], Iterable)) <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(<span class="hljs-number">123</span>, Iterable)) <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><h2 id="判断对象是否是可调用对象"><a href="#判断对象是否是可调用对象" class="headerlink" title="判断对象是否是可调用对象"></a>判断对象是否是可调用对象</h2><p>Python中的内置函数<code>callable</code>可用于判断对象是否可以调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">callable</span>(<span class="hljs-built_in">print</span>)) <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">callable</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)) <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.runoob.com/note/33502">《Python is 与 == 区别》菜鸟教程</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python迭代器实现</title>
    <link href="/2021/09/16/blog/Python/Python%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/09/16/blog/Python/Python%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Python迭代器实现"><a href="#Python迭代器实现" class="headerlink" title="Python迭代器实现"></a>Python迭代器实现</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在Python编程中，我们经常使用<code>for-in</code>语句对容器进行迭代。容器类(<em>比如列表、元组等</em>)之所以可以被for-in语句迭代，是因为这些容器类实现了<code>__iter__</code>魔术方法。这个方法返回一个<code>迭代器对象</code>。迭代器对象实现了<code>__next__</code>魔术方法，这个方法可以移动迭代器和获取迭代器指向的值。如果我们想要实现支持迭代的对象，只需要实现__iter__方法以及__iter__返回的迭代器对象的__next__方法即可。</p><h2 id="iter-和-next"><a href="#iter-和-next" class="headerlink" title="__iter__和__next__"></a>__iter__和__next__</h2><p>__iter__方法的作用是返回一个迭代器对象。这个迭代器对象需要实现__next__方法(<em>一般也需要实现__iter__方法</em>)。迭代器对象在内部保存了它的状态(<em>迭代器在容器中的位置</em>)。__next__方法将迭代器向后移动一个位置并返回迭代器指向的值。__iter__刚返回的迭代器对象指向“第0个元素”，调用__next__会将迭代器移动到第一个元素的位置，然后返回容器中的第一个元素。再次调用__next__会将迭代器移到第二个元素的位置并返回第二个元素，以此类推。如果迭代器已经移动到了容器的最后一个元素，继续调用__next__会抛出<code>StopIterator</code>异常。后续调用__next__仍然会抛出这个异常，如果我们实现自己的迭代器，也需要遵守这个规定。</p><p>以下这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> obj:<br>    <span class="hljs-keyword">pass</span> <span class="hljs-comment"># do something</span><br></code></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">iterator = obj.__iter__()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        i = obj.__next__()<br>        <span class="hljs-keyword">pass</span> <span class="hljs-comment"># do something</span><br>    <span class="hljs-keyword">except</span> StopIteration:<br>        <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><h2 id="实现可迭代的斐波那契数列类"><a href="#实现可迭代的斐波那契数列类" class="headerlink" title="实现可迭代的斐波那契数列类"></a>实现可迭代的斐波那契数列类</h2><p>在本节中我们将使用之前提到的迭代器的实现方法实现可迭代的斐波那契数列类——Fibonacci。Fibonacci类的构造函数接受一个参数x。我们对一个Fibonacci对象迭代可以获取从1到x这一区间内所有的斐波那契数的序列。实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Iterator</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.x = x<br>        self.n1 = <span class="hljs-number">0</span><br>        self.n2 = <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span>(<span class="hljs-params">self</span>):</span><br>        self.n1, self.n2 = self.n2, self.n1 + self.n2<br>        <span class="hljs-keyword">if</span> self.n1 &gt; self.x:<br>            <span class="hljs-keyword">raise</span> StopIteration<br>        <span class="hljs-keyword">return</span> self.n1<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fibonacci</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.x = x<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> Iterator(self.x)<br><br><br><span class="hljs-comment"># 例子</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> Fibonacci(<span class="hljs-number">100</span>):<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator-types">迭代器类型</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>迭代器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python字符串格式化</title>
    <link href="/2021/08/31/blog/Python/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <url>/2021/08/31/blog/Python/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Python字符串格式化"><a href="#Python字符串格式化" class="headerlink" title="Python字符串格式化"></a>Python字符串格式化</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>字符串格式化</code>是我们在使用<strong>Python</strong>中经常用到的功能。Python为我们提供了<strong>四种</strong>格式化字符串的方法，分别是<code>%运算符</code>、<code>字符串format方法</code>、<code>格式化字符串字面值</code>以及<code>模板字符串</code>。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="%运算符"></a>%运算符</h2><p><code>%运算符</code>提供了一种<em>printf风格的字符串格式化</em>，它的用法跟C语言中的<strong>printf</strong>十分相似。先来看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;我叫%s, 今年%d岁。&quot;</span> % (<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>) <span class="hljs-comment"># 我叫小明, 今年18岁。</span><br><span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><p>使用%运算符格式化字符串的语法是<code>format % values</code>。<code>format</code>是一个<strong>字符串</strong>，values可以是一个<strong>对象</strong>、<strong>元组</strong>或<strong>字典</strong>，format中会有若干个’%’开头的<code>标记转换符</code>，例如“%d”代表一个整数，“%s”代表一个字符串，这些标记转换符会被values中的条目替换。</p><p>当<strong>value</strong>是一个元组时，需要每个转换符与value中的条目<strong>一一对应</strong>，可以为标记转换符添加<strong>映射键</strong>,value的类型应为字典。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;我叫%(name)s, 今年%(age)d岁。&quot;</span> % &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>&#125;<br><span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><p>转换标记符包含两个或更多字符并具有以下组成，且必须遵循此处规定的顺序：</p><blockquote><ol><li>‘%’ 字符，用于标记转换符的起始。</li><li>映射键（可选），由加圆括号的字符序列组成 (例如 (somename))。</li><li>转换旗标（可选），用于影响某些转换类型的结果。</li><li>最小字段宽度（可选）。 如果指定为 ‘*’ (星号)，则实际宽度会从 values 元组的下一元素中读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。</li><li>精度（可选），以在 ‘.’ (点号) 之后加精度值的形式给出。 如果指定为 ‘*’ (星号)，则实际精度会从 values 元组的下一元素中读取，要转换的对象则为精度之后的元素。</li><li>长度修饰符（可选）。</li><li>转换类型。</li></ol></blockquote><p>以下是转换符列表：</p><table><thead><tr><th align="center">转换符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">‘d’</td><td align="center">有符号十进制整数。</td></tr><tr><td align="center">‘i’</td><td align="center">有符号十进制整数。</td></tr><tr><td align="center">‘o’</td><td align="center">有符号八进制数。</td></tr><tr><td align="center">‘u’</td><td align="center">过时类型 – 等价于 ‘d’。</td></tr><tr><td align="center">‘x’</td><td align="center">有符号十六进制数（小写）。</td></tr><tr><td align="center">‘X’</td><td align="center">有符号十六进制数（大写）。</td></tr><tr><td align="center">‘e’</td><td align="center">浮点指数格式（小写）。</td></tr><tr><td align="center">‘E’</td><td align="center">浮点指数格式（大写）。</td></tr><tr><td align="center">‘f’</td><td align="center">浮点十进制格式。</td></tr><tr><td align="center">‘F’</td><td align="center">浮点十进制格式。</td></tr><tr><td align="center">‘g’</td><td align="center">浮点格式。 如果指数小于 -4 或不小于精度则使用小写指数格式，否则使用十进制格式。</td></tr><tr><td align="center">‘G’</td><td align="center">浮点格式。 如果指数小于 -4 或不小于精度则使用大写指数格式，否则使用十进制格式。</td></tr><tr><td align="center">‘c’</td><td align="center">单个字符（接受整数或单个字符的字符串）。</td></tr><tr><td align="center">‘r’</td><td align="center">字符串（使用 repr() 转换任何 Python 对象）。</td></tr><tr><td align="center">‘s’</td><td align="center">字符串（使用 str() 转换任何 Python 对象）。</td></tr><tr><td align="center">‘a’</td><td align="center">字符串（使用 ascii() 转换任何 Python 对象）。</td></tr><tr><td align="center">‘%’</td><td align="center">不转换参数，在结果中输出一个 ‘%’ 字符。</td></tr></tbody></table><p>转换标志列表：</p><table><thead><tr><th align="center">标志</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">‘#’</td><td align="center">值的转换将使用“替代形式”（具体定义见下文）。</td></tr><tr><td align="center">‘0’</td><td align="center">转换将为数字值填充零字符。</td></tr><tr><td align="center">‘-‘</td><td align="center">转换值将靠左对齐（如果同时给出 ‘0’ 转换，则会覆盖后者）。</td></tr><tr><td align="center">‘ ‘</td><td align="center">(空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。</td></tr><tr><td align="center">‘+’</td><td align="center">符号字符 (‘+’ 或 ‘-‘) 将显示于转换结果的开头（会覆盖 “空格” 旗标）。</td></tr></tbody></table><p>Python官方文档并不建议我们使用这种方法，因为这种方法不仅需要标识转换符与value一一对应，而且还不能正确格式化<strong>元组</strong>，<strong>列表</strong>等类型。所以，在Python中使用格式化字符串建议使用以下三种方法。</p><h2 id="字符串format方法"><a href="#字符串format方法" class="headerlink" title="字符串format方法"></a>字符串format方法</h2><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;&#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment"># 1 + 2 = 3</span><br><span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><p><code>format</code>会将参数依次替换字符串中的<code>&#123;&#125;</code>并返回一个新的str对象。如果需要输出<code>&#123;&#125;</code>需要用两层花括号(<code>&#123;&#123;&#125;&#125;</code>)</p><p>“{}”可以具有位置参数，format方法将会用指定位置的参数代替花括号。如果使用位置参数，那么所有的花括号中都必须有位置参数。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;&#123;1&#125; + &#123;0&#125; = &#123;2&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><p>“{}”中还可以具有<code>关键字参数</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;我叫&#123;name&#125;, 今年&#123;age&#125;岁。&quot;</span>.<span class="hljs-built_in">format</span>(name=<span class="hljs-string">&quot;小明&quot;</span>, age=<span class="hljs-number">18</span>)<br><span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><p>位置参数和关键字参数可以混用。</p><p>可以使用<code>**</code>传递字典作为关键字参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">table = &#123;<span class="hljs-string">&#x27;Sjoerd&#x27;</span>: <span class="hljs-number">4127</span>, <span class="hljs-string">&#x27;Jack&#x27;</span>: <span class="hljs-number">4098</span>, <span class="hljs-string">&#x27;Dcab&#x27;</span>: <span class="hljs-number">8637678</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Jack: &#123;Jack:d&#125;; Sjoerd: &#123;Sjoerd:d&#125;; Dcab: &#123;Dcab:d&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(**table))<br><span class="hljs-comment"># Jack: 4098; Sjoerd: 4127; Dcab: 8637678</span><br></code></pre></td></tr></table></figure><p>还可以在花括号中添加格式化参数，详见<a href="https://docs.python.org/zh-cn/3/library/string.html#formatstrings">格式字符串语法</a>。</p><h2 id="格式化字符串字面值"><a href="#格式化字符串字面值" class="headerlink" title="格式化字符串字面值"></a>格式化字符串字面值</h2><p>Python3.6新增加了<code>格式化字符串字面值</code>的特性，可以方便的格式化字符串。</p><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;小明&quot;</span><br>age = <span class="hljs-number">18</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;我叫<span class="hljs-subst">&#123;name&#125;</span>, 今年<span class="hljs-subst">&#123;age&#125;</span>岁。&quot;</span>)<br><span class="hljs-comment"># 我叫小明, 今年18岁。</span><br></code></pre></td></tr></table></figure><p>当我们在一个字符串前标注一个<code>&#39;f&#39;</code>或<code>&#39;F&#39;</code>时，Python解释器就认为这个字符串是一个<strong>格式化字符串字面值</strong>。在这个字符串中使用“{}”将一个变量或表达式括起来，Python就会用变量或表达式的内容替换“{}”。格式化字符串字面值还可以使用<strong>格式说明符</strong>，用法与str.format相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">price = <span class="hljs-number">12.567</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;苹果的价格是<span class="hljs-subst">&#123;price:<span class="hljs-number">.2</span>f&#125;</span>&quot;</span>) <span class="hljs-comment"># 苹果的价格是12.57</span><br></code></pre></td></tr></table></figure><p>转换符<code>!s</code>、<code>!r</code>、<code>!a</code>分别调用<code>str</code>、<code>repr</code>、<code>ascii</code>对表达式进行求值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;小明&quot;</span>, age: <span class="hljs-built_in">int</span> = <span class="hljs-number">18</span></span>):</span><br>        self.name: <span class="hljs-built_in">str</span> = name<br>        self.age: <span class="hljs-built_in">int</span> = age<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.name + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">str</span>(self.age) + <span class="hljs-string">&quot; __str__&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.name + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">str</span>(self.age) + <span class="hljs-string">&quot; __repr__&quot;</span><br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;Student()!s&#125;</span>\n<span class="hljs-subst">&#123;Student()!r&#125;</span>\n<span class="hljs-subst">&#123;Student()!a&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 小明 18 __str__</span><br><span class="hljs-comment"># 小明 18 __repr__</span><br><span class="hljs-comment"># \u5c0f\u660e 18 __repr__</span><br></code></pre></td></tr></table></figure><p>格式表达式中不能有反斜杠，否则会报错。即便未包含表达式，格式字符串字面值也不能用作文档字符串。</p><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>Python提供的<code>Template类</code>也可以用来格式化字符串，它位于<strong>string</strong>包。使用Template类时，实现实例化一个Template对象。然后调用<code>substitute</code>或<code>safe_substitute</code>用传入的参数替换模板字符串中的变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">t = Template(<span class="hljs-string">&quot;我叫$name, 今年$age岁。&quot;</span>)<br>s = t.substitute(name=<span class="hljs-string">&quot;小明&quot;</span>, age=<span class="hljs-number">18</span>)<br><span class="hljs-built_in">print</span>(s)<br>s = t.substitute(&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>&#125;)<br><span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><p>$identifier为替换占位符，它会匹配一个名为 “identifier” 的映射键。如果映射键有歧义可以使用花括号区分。否则Python将匹配尽可能多的字符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(Template(<span class="hljs-string">&quot;$ab&quot;</span>).substitute(a=<span class="hljs-number">1</span>, ab=<span class="hljs-number">2</span>))  <span class="hljs-comment"># 2</span><br><span class="hljs-built_in">print</span>(Template(<span class="hljs-string">&quot;$&#123;a&#125;b&quot;</span>).substitute(a=<span class="hljs-number">1</span>, ab=<span class="hljs-number">2</span>))  <span class="hljs-comment"># 1b</span><br><span class="hljs-built_in">print</span>(Template(<span class="hljs-string">&quot;$&#123;ab&#125;&quot;</span>).substitute(a=<span class="hljs-number">1</span>, ab=<span class="hljs-number">2</span>))  <span class="hljs-comment"># 2</span><br></code></pre></td></tr></table></figure><p><strong>substitute</strong>或<strong>safe_substitute</strong>可以接受关键字参数或者字典。这两个方法的区别在于，模板字符串中的一个标识符在传入方法的参数中没有条目与之对应时，substatute会抛出<code>ValueError</code>，而safe_substitute会保留$和标识符而不进行替换。</p><p>想要在字符串中保留<code>$</code>可以用<code>$$</code>转义。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://blog.csdn.net/qq_27825451/article/details/105652244">python字符串格式化深入详解（四种方法）</a></p></li><li><p><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#printf-style-string-formatting">printf 风格的字符串格式化</a></p></li><li><p><a href="https://docs.python.org/zh-cn/3/library/string.html">string — 常见的字符串操作</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Unix域套接字</title>
    <link href="/2021/08/26/blog/Linux/%E6%B5%85%E8%B0%88Unix%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    <url>/2021/08/26/blog/Linux/%E6%B5%85%E8%B0%88Unix%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="浅谈-Unix-域套接字"><a href="#浅谈-Unix-域套接字" class="headerlink" title="浅谈 Unix 域套接字"></a>浅谈 Unix 域套接字</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在 <strong>Linux</strong> 中有许多进行 <code>进程间通信</code> 的方法。今天博主向大家介绍一种常用的进程间通信的方法 ——<code>Unix 域套接字</code>。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Unix 域套接字</code> 是一种在本机的进程间进行通信的一种方法。虽然 Unix 域套接字的接口与 <code>TCP 和 UDP 套接字</code> 的接口十分相似，但是 Unix 域套接字只能用于同一台机器的进程间通信，不能让两个位于不同机器的进程进行通信。正由于这个特性，Unix 域套接字可以可靠地在两个进程间复制数据，不用像 TCP 一样采用一些诸如 * 添加网络报头 <em>、</em> 计算检验和 <em>、</em> 产生顺序号 * 等一系列保证数据完整性的操作。因此，在同一台机器上进行进程间通信时，Unix 域套接字的效率往往比 TCP 套接字的效率要高。</p><p>因为 Unix 域套接字的效率比较高，一些程序经常用 Unix 套接字代替 TCP 套接字。例如当 MySQL 的服务器进程和客户端进程在同一台机器上时，可以用 Unix 域套接字代替 TCP 套接字。</p><h2 id="Unix-域套接字地址结构"><a href="#Unix-域套接字地址结构" class="headerlink" title="Unix 域套接字地址结构"></a>Unix 域套接字地址结构</h2><p>在使用 TCP 套接字和 UDP 套接字时，我们需要用 <code>struct sockaddr_in</code>（<em>IPv4</em>）定义套接字的地址结构，与之相似，Unix 域套接字使用 <code>struct sockaddr_un</code> 定义套接字的地址结构。<code>struct sockaddr_un</code> 的定义如下（* 位于头文件 sys/un.h 中 *）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">sa_family_t</span> sun_family;<br>    <span class="hljs-keyword">char</span> sun_path[<span class="hljs-number">108</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>在使用 Internet 域套接字进行编程时，需要将 <code>struct sockaddr_in</code> 的 <code>sin_family</code> 成员设置为 <code>AF_INET</code>（<em>IPv4</em>）。与之类似，在使用 Unix 域套接字时，需要将 sun_family 设置为 <code>AF_UNIX</code> 或 <code>AF_LOCAL</code>（* 这两个宏的作用完全相同，都表示 UNIX 域 *）。<code>struct sockaddr_un</code> 的第二个成员 <code>sun_path</code> 表示 socket 的地址。在 Unix 域中，socket 的地址用路径名表示。例如，可以将 sun_path 设置为 <code>/tmp/unixsock</code>。由于路径名是一个字符串，所以 sun_path 必须能够容纳字符串的字符和结尾的 <code>&#39;\0&#39;</code>。需要注意的是，标准并没有规定 sun_path 的大小，在某些平台中，sun_path 的大小可能是 104、92 等值。所以如果需要保证可移植性，在编码时应该使用 sun_path 的最小值。</p><h2 id="创建-Unix-域套接字"><a href="#创建-Unix-域套接字" class="headerlink" title="创建 Unix 域套接字"></a>创建 Unix 域套接字</h2><p>Unix 域套接字使用 <code>socket</code> 函数创建，与 Internet 域套接字一样，Unix 域套接字也有流套接字和数据报套接字两种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> unix_sock_fd1 = socket(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>); <span class="hljs-comment">// Unix 域中的流 socket</span><br><span class="hljs-keyword">int</span> unix_sock_fd2 = socket(AF_UNIX, SOCK_DGRAM, <span class="hljs-number">0</span>); <span class="hljs-comment">// Unix 域中的数据包 socket</span><br></code></pre></td></tr></table></figure><p>稍后将介绍这两种套接字的用法和区别。</p><h2 id="绑定-Unix-域套接字"><a href="#绑定-Unix-域套接字" class="headerlink" title="绑定 Unix 域套接字"></a>绑定 Unix 域套接字</h2><p>使用 <code>bind</code> 函数可以将一个 Unix 套接字绑定到一个地址上。绑定 Unix 域套接字时，bind 会在指定的路径名处创建一个表示 Unix 域套接字的文件。Unix 域套接字与路径名是一一对应关系，即一个 Unix 域套接字只能绑定到一个路径名上，一个路径名也只能被一个套接字绑定。一般要把 Unix 域套接字绑定到一个 <code>绝对路径</code> 上，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">addr</span>;</span><br>addr.sun_family = AF_LOCAL;<br><span class="hljs-built_in">strcpy</span>(addr.sun_path, <span class="hljs-string">&quot;/tmp/sockaddr&quot;</span>);<br><span class="hljs-keyword">int</span> unix_sock_fd = socket(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (bind(unix_sock_fd, (struct sockaddr *)&amp;addr, <span class="hljs-keyword">sizeof</span>(addr)) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;bind error\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Unix 域套接字被绑定后，可以使用 getsockname 获取套接字绑定的路径名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">addr2</span>;</span><br><span class="hljs-keyword">socklen_t</span>          len = <span class="hljs-keyword">sizeof</span>(addr2);<br>getsockname(unix_sock_fd, (struct sockaddr *)&amp;addr2, &amp;len);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, addr2.sun_path);<br></code></pre></td></tr></table></figure><p>当一个 Unix 域套接字不再使用时，应当调用 <code>unlink</code> 将其删除。</p><h2 id="Unix-域中的流-socket"><a href="#Unix-域中的流-socket" class="headerlink" title="Unix 域中的流 socket"></a>Unix 域中的流 socket</h2><p>Unix 域中的流套接字与 TCP 流套接字的用法十分相似。在服务器端，我们首先创建一个 Unix 域流套接字，将其绑定到一个路径上，然后调用 <code>listen</code> 监听客户端连接，调用 <code>accept</code> 接受客户端的连接。在客户端，在创建一个 Unix 域流套接字之后，可以使用 <code>connect</code> 尝试连接指定的服务器套接字。以下是一个使用 Unix 域流套接字实现的 echo 服务器和客户端的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 服务器</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/un.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UNIX_SOCKET_PATH <span class="hljs-meta-string">&quot;/tmp/echo_unix_socket&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BACKLOG          5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MSG_MAX_LENGTH   100</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">echo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> client_fd)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">readLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">char</span> *buf)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signalHandler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signo)</span>    <span class="hljs-comment">// NOLINT</span></span><br><span class="hljs-function"></span>&#123;<br>    unlink(UNIX_SOCKET_PATH);    <span class="hljs-comment">// NOLINT</span><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);          <span class="hljs-comment">// NOLINT</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (signal(SIGINT, signalHandler) == SIG_ERR)    <span class="hljs-comment">// NOLINT</span><br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;signal error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> listen_fd = socket(AF_LOCAL, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (listen_fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;socket error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">unix_socket_addr</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;unix_socket_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(unix_socket_addr));<br>    unix_socket_addr.sun_family = AF_LOCAL;<br>    <span class="hljs-built_in">strcpy</span>(unix_socket_addr.sun_path, UNIX_SOCKET_PATH);<br>    <span class="hljs-keyword">if</span> (bind(listen_fd, (struct sockaddr *)&amp;unix_socket_addr, <span class="hljs-keyword">sizeof</span>(unix_socket_addr))<br>        &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;bind error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (listen(listen_fd, BACKLOG) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;listen error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        <span class="hljs-keyword">int</span> client_fd = accept(listen_fd, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span> (client_fd &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;accept error\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">switch</span> (fork())<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>            &#123;<br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork error\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            &#123;<br>                echo(client_fd);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">default</span>:<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">echo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> client_fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[MSG_MAX_LENGTH + <span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        readLine(client_fd, buf);<br>        <span class="hljs-keyword">int</span> msg_len = (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">strlen</span>(buf);<br>        <span class="hljs-keyword">if</span> (write(client_fd, buf, msg_len) != msg_len)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;write error\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    <span class="hljs-comment">// NOLINT</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">readLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">char</span> *buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; i &lt; MSG_MAX_LENGTH; i++)<br>    &#123;<br>        <span class="hljs-keyword">switch</span> (read(fd, buf + i, <span class="hljs-number">1</span>))<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            &#123;<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    <span class="hljs-comment">// NOLINT</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>            &#123;<br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;read error\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    <span class="hljs-comment">// NOLINT</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">default</span>:<br>            &#123;<br>                assert(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (buf[i] == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>        &#123;<br>            i++;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    buf[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 客户端</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/un.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UNIX_SOCKET_PATH <span class="hljs-meta-string">&quot;/tmp/echo_unix_socket&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MSG_MAX_LENGTH   100</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> socket_fd = socket(AF_LOCAL, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (socket_fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;socker error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">addr</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(addr));<br>    addr.sun_family = AF_LOCAL;<br>    <span class="hljs-built_in">strcpy</span>(addr.sun_path, UNIX_SOCKET_PATH);<br>    <span class="hljs-keyword">if</span> (connect(socket_fd, (struct sockaddr *)&amp;addr, <span class="hljs-keyword">sizeof</span>(addr)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;sonnect error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">char</span> buf[MSG_MAX_LENGTH + <span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        fgets(buf, MSG_MAX_LENGTH, <span class="hljs-built_in">stdin</span>);<br>        <span class="hljs-keyword">int</span> len = (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">strlen</span>(buf);<br>        <span class="hljs-keyword">if</span> (write(socket_fd, buf, len) != len)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;write error\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (read(socket_fd, buf, len) != len)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;read error\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Unix-域中的数据报-socket"><a href="#Unix-域中的数据报-socket" class="headerlink" title="Unix 域中的数据报 socket"></a>Unix 域中的数据报 socket</h2><p><code>Unix 域数据报套接字</code> 与 <code>UDP 套接字</code> 类似，可以通过 Unix 域数据报套接字在进程间发送具有边界的数据报。但由于 Unix 域数据报套接字是在本机上进行通信，所以 Unix 域数据报套接字的数据传递是可靠的，不会像 UDP 套接字那样发生丢包的问题。Unix 域数据报套接字的接口与 UDP 也十分相似。在服务器端，通常先创建一个 Unix 域数据报套接字，然后将其绑定到一个路径上。然后调用 <code>recvfrom</code> 接收客户端发送来的数据，调用 <code>sendto</code> 向客户端发送数据。对于客户端，通常是先创建一个 Unix 域数据报套接字，将这个套接字绑定到一个路径上，然后调用 <code>sendto</code> 发送数据，调用 <code>recvfrom</code> 接收客户端发来的数据。以下是使用 Unix 域数据报套接字实现的 echo 服务器和客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 服务器</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/un.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UNIX_SOCKET_PATH <span class="hljs-meta-string">&quot;/tmp/echo_unix_socket&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MSG_MAX_LENGTH   100</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signalHandler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signo)</span>    <span class="hljs-comment">// NOLINT</span></span><br><span class="hljs-function"></span>&#123;<br>    unlink(UNIX_SOCKET_PATH);    <span class="hljs-comment">// NOLINT</span><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);          <span class="hljs-comment">// NOLINT</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (signal(SIGINT, signalHandler) == SIG_ERR)    <span class="hljs-comment">// NOLINT</span><br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;signal error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> listen_fd = socket(AF_LOCAL, SOCK_DGRAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (listen_fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;socket error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">addr</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(addr));<br>    addr.sun_family = AF_LOCAL;<br>    <span class="hljs-built_in">strcpy</span>(addr.sun_path, UNIX_SOCKET_PATH);<br>    <span class="hljs-keyword">if</span> (bind(listen_fd, (struct sockaddr *)&amp;addr, <span class="hljs-keyword">sizeof</span>(addr)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;bind error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">char</span> buf[MSG_MAX_LENGTH + <span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">client_addr</span>;</span><br>        <span class="hljs-keyword">socklen_t</span>          len     = <span class="hljs-keyword">sizeof</span>(client_addr);<br>        <span class="hljs-keyword">int</span>                msg_len = (<span class="hljs-keyword">int</span>)recvfrom(listen_fd,<br>                                    buf,<br>                                    MSG_MAX_LENGTH,<br>                                    <span class="hljs-number">0</span>,<br>                                    (struct sockaddr *)&amp;client_addr,<br>                                    &amp;len);<br>        <span class="hljs-keyword">if</span> (msg_len &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;recvfrom error\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sendto(listen_fd, buf, msg_len, <span class="hljs-number">0</span>, (struct sockaddr *)&amp;client_addr, len) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;sendto error\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 客户端</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/un.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UNIX_SOCKET_PATH       <span class="hljs-meta-string">&quot;/tmp/echo_unix_socket&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MSG_MAX_LENGTH         100</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SOCKET_PATH_MAX_LENGTH 50</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signalHandler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signo)</span>    <span class="hljs-comment">// NOLINT</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> socket_path[SOCKET_PATH_MAX_LENGTH] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">sprintf</span>(socket_path, <span class="hljs-string">&quot;/tmp/echo_unix_socket_%ld&quot;</span>, (<span class="hljs-keyword">long</span>)getpid());    <span class="hljs-comment">// NOLINT</span><br>    unlink(socket_path);                                                  <span class="hljs-comment">// NOLINT</span><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);                                                   <span class="hljs-comment">// NOLINT</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (signal(SIGINT, signalHandler) == SIG_ERR)    <span class="hljs-comment">// NOLINT</span><br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;signal error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> socket_fd = socket(AF_LOCAL, SOCK_DGRAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (socket_fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;socket error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">server_addr</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;server_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(server_addr));<br>    server_addr.sun_family = AF_LOCAL;<br>    <span class="hljs-built_in">strcpy</span>(server_addr.sun_path, UNIX_SOCKET_PATH);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">client_addr</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;client_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(client_addr));<br>    client_addr.sun_family = AF_LOCAL;<br>    <span class="hljs-built_in">sprintf</span>(client_addr.sun_path, <span class="hljs-string">&quot;/tmp/echo_unix_socket_%ld&quot;</span>, (<span class="hljs-keyword">long</span>)getpid());<br><br>    <span class="hljs-keyword">if</span> (bind(socket_fd, (struct sockaddr *)&amp;client_addr, <span class="hljs-keyword">sizeof</span>(client_addr)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;bind error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">char</span> buf[MSG_MAX_LENGTH + <span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        fgets(buf, MSG_MAX_LENGTH, <span class="hljs-built_in">stdin</span>);<br>        <span class="hljs-keyword">int</span> msg_len = (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">strlen</span>(buf);<br>        <span class="hljs-keyword">if</span> (sendto(socket_fd,<br>                   buf,<br>                   msg_len,<br>                   <span class="hljs-number">0</span>,<br>                   (struct sockaddr *)&amp;server_addr,<br>                   <span class="hljs-keyword">sizeof</span>(server_addr))<br>            &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;sendto error\n&quot;</span>);    <span class="hljs-comment">// NOLINT</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (recvfrom(socket_fd, buf, MSG_MAX_LENGTH, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;recvfrom error\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Unix-域套接字的权限"><a href="#Unix-域套接字的权限" class="headerlink" title="Unix 域套接字的权限"></a>Unix 域套接字的权限</h2><p>当程序调用 <code>bind</code> 时，会在文件系统中的指定路径处创建一个与套接字对应的文件。我们可以通过控制该文件的权限来控制进程对这个套接字的访问。当进程想要连接一个 Unix 域流套接字或通过一个 Unix 域数据报套接字发送数据包时，需要拥有对该套接字的 <code>写权限</code> 以及对 socket 路径名的所有目录的 <code>执行权限</code>。在调用 <code>bind</code> 时，会自动赋予用户、组和其他用户的所有权限。如果想要修改这一行为，可以在调用 <code>bind</code> 之前调用 <code>umask</code> 禁用掉某些权限。</p><h2 id="使用-socketpair-创建互联的-socket-对"><a href="#使用-socketpair-创建互联的-socket-对" class="headerlink" title="使用 socketpair 创建互联的 socket 对"></a>使用 socketpair 创建互联的 socket 对</h2><p>有时我们需要在同一个进程中创建一对相互连接的 Unix 域 socket（* 与管道类似 *），这可以通过 <code>socket</code>、<code>bind</code>、<code>listen</code>、<code>accept</code> 和 <code>connect</code> 等调用实现。而 <code>socketpair</code> 提供了一个简单方便的方法来创建一对互联的 socket。<code>socketpair</code> 创建的一对 socket 是 <code>全双工</code> 的。socketpair 的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">socketpair</span><span class="hljs-params">(<span class="hljs-keyword">int</span> domain, <span class="hljs-keyword">int</span> type, <span class="hljs-keyword">int</span> protocol, <span class="hljs-keyword">int</span> socketfd[<span class="hljs-number">2</span>])</span></span>;<br></code></pre></td></tr></table></figure><p>socketpair 的前三个参数与 <code>socket</code> 函数的含义相同。由于 socketpair 只能用于 Unix 域套接字，所以 <code>domain</code> 参数必须是 <code>AF_UNIX</code> 或 <code>AF_LOCAL</code>。<code>type</code> 参数可以是 <code>SOCK_DGRAM</code> 或 <code>SOCK_STREAM</code>，分别创建一对数据报 socket 或流 socket。<code>protocol</code> 参数必须是 0。<code>socketfd</code> 用于返回创建的两个套接字文件描述符。</p><p>通常，在调用 socketpair 创建一对套接字后会调用 fork 创建子进程，这样父进程和子进程就可以通过这一对套接字进行进程间通信了。</p><h2 id="使用-Unix-域套接字传递描述符"><a href="#使用-Unix-域套接字传递描述符" class="headerlink" title="使用 Unix 域套接字传递描述符"></a>使用 Unix 域套接字传递描述符</h2><p>Unix 域套接字的一个 “特色功能” 就是在进程间 <code>传递描述符</code>。描述符可以通过 Unix 域套接字在没有亲缘关系的进程之间传递。描述符是一种 <code>辅助数据</code>，可以通过 <code>sendmsg</code> 发送，通过 <code>recvmsg</code> 接收。这里的 <code>描述符</code> 可以是 <code>open</code>、<code>pipe</code>、<code>mkfifo</code>、<code>socket</code>、<code>accept</code> 等函数打开的描述符。以下是一个子进程向父进程传递描述符的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUF_SIZE  1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEXT_SIZE 12</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendFd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> socket_fd)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">recvFd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> socket_fd)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> fd_pair[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-keyword">if</span> (socketpair(AF_LOCAL, SOCK_STREAM, <span class="hljs-number">0</span>, fd_pair) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;socket error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        close(fd_pair[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">int</span>  recv_fd             = recvFd(fd_pair[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">char</span> text[TEXT_SIZE + <span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">if</span> (read(recv_fd, text, TEXT_SIZE) != TEXT_SIZE)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;read error\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, text);<br>        <span class="hljs-keyword">if</span> (waitpid(pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;waitpid error\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    close(fd_pair[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// ./hello.txt的内容为&quot;hello world\n&quot;</span><br>    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">&quot;./hello.txt&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;open error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    <span class="hljs-comment">// NOLINT</span><br>    &#125;<br><br>    sendFd(fd, fd_pair[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendFd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> socket_fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msghdr</span> <span class="hljs-title">msg</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(msg));<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">iov</span>;</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">    &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmsghdr</span> <span class="hljs-title">cm</span>;</span><br>        <span class="hljs-keyword">char</span>           control[CMSG_SPACE(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>))];<br>    &#125; control_un;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmsghdr</span> *<span class="hljs-title">cmptr</span>      =</span> <span class="hljs-literal">NULL</span>;<br>    msg.msg_control            = control_un.control;<br>    msg.msg_controllen         = <span class="hljs-keyword">sizeof</span>(control_un.control);<br>    cmptr                      = CMSG_FIRSTHDR(&amp;msg);<br>    cmptr-&gt;cmsg_len            = CMSG_LEN(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>    cmptr-&gt;cmsg_level          = SOL_SOCKET;<br>    cmptr-&gt;cmsg_type           = SCM_RIGHTS;<br>    *((<span class="hljs-keyword">int</span> *)CMSG_DATA(cmptr)) = fd;<br>    msg.msg_name               = <span class="hljs-literal">NULL</span>;<br>    msg.msg_namelen            = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> buf[BUF_SIZE]         = &#123;<span class="hljs-number">0</span>&#125;;<br>    iov.iov_base               = &amp;buf;<br>    iov.iov_len                = BUF_SIZE;<br>    msg.msg_iov                = &amp;iov;<br>    msg.msg_iovlen             = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (sendmsg(socket_fd, &amp;msg, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;sendmsg error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    <span class="hljs-comment">// NOLINT</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">recvFd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> socket_fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msghdr</span> <span class="hljs-title">msg</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(msg));<br><br>    <span class="hljs-keyword">char</span>         buf[BUF_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">iov</span>;</span><br>    iov.iov_base = buf;<br>    iov.iov_len  = BUF_SIZE;<br><br>    <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">    &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmsghdr</span> <span class="hljs-title">cm</span>;</span><br>        <span class="hljs-keyword">char</span>           control[CMSG_SPACE(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>))];<br>    &#125; control_un;<br><br>    msg.msg_control       = control_un.control;<br>    msg.msg_controllen    = <span class="hljs-keyword">sizeof</span>(control_un.control);<br>    msg.msg_name          = <span class="hljs-literal">NULL</span>;<br>    msg.msg_namelen       = <span class="hljs-number">0</span>;<br>    msg.msg_iov           = &amp;iov;<br>    msg.msg_iovlen        = <span class="hljs-number">1</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmsghdr</span> *<span class="hljs-title">cmptr</span> =</span> CMSG_FIRSTHDR(&amp;msg);<br><br>    <span class="hljs-keyword">if</span> (recvmsg(socket_fd, &amp;msg, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;recvmsg error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    <span class="hljs-comment">// NOLINT</span><br>    &#125;<br><br>    <span class="hljs-keyword">int</span> fd = *((<span class="hljs-keyword">int</span> *)CMSG_DATA(cmptr));<br>    <span class="hljs-keyword">return</span> fd;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>《UNIX 网络编程 卷 1 套接字联网 API（第 3 版）》</li><li>《Linux/UNIX 系统编程手册（下册）》</li><li><a href="https://www.cnblogs.com/nufangrensheng/p/3569416.html">高级进程间通信之 UNIX 域套接字 - ITtecman - 博客园</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Unix域套接字</tag>
      
      <tag>进程间通信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++多线程编程（二）：使用互斥锁</title>
    <link href="/2021/08/13/blog/C++/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81/"/>
    <url>/2021/08/13/blog/C++/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="C-多线程编程（二）：使用互斥锁"><a href="#C-多线程编程（二）：使用互斥锁" class="headerlink" title="C++多线程编程（二）：使用互斥锁"></a>C++多线程编程（二）：使用互斥锁</h1><p><a href="https://liu-shuhang.github.io/blog/2021/08/10/blog/C++/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8thread%E7%B1%BB/">上回书</a>说到，我们可以用C++11中的<code>thread类</code>来创建和管理线程。在多线程编程中，我们常常遇到对线程间共享数据访问的各种线程安全问题。在这篇博文中我将向大家介绍如何利用C++11提供的<code>&lt;mutex&gt;</code>头文件提供的相关工具来保护线程间共享数据。</p><h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p>首先来看一段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x = n;<br>        n++;<br>        <span class="hljs-keyword">if</span> (x + <span class="hljs-number">1</span> == n)<br>        &#123;<br>            n--;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">t3</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    t3.<span class="hljs-built_in">join</span>();<br><br>    cout &lt;&lt; n &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>读者不妨先猜测一下输出结果。</p><p>一种可能的猜测：</p><blockquote><p>在函数<code>func</code>中，我们先把n赋值给x，然后让n递增1。按理说，表达式<code>x + 1 == n</code>的结果应该为<code>true</code>，那么n又会递减1。也就是说，执行一次循环，n的值应该不会改变。所以程序最终的输出结果应该是0。<br>几句就<br>我们运行一下这个程序看一下结果：</p></blockquote><blockquote><p>548 // 第一次运行结果</p><p>96  // 第二次运行结果</p><p>162 // 第三次运行结果</p></blockquote><p>肿么肥四？为什么每次运行结果都不一致？要想搞清楚这样的结果的原因，首先要从<code>线程调度</code>说起：</p><p>操作系统在调度线程时采用的是<code>抢占式调度</code>的方式，也就是说，每一个线程在执行一段时间后会被操作系统中断，然后调用另一个线程。操作系统对线程的调度几乎是<code>随机</code>的。在上面的例子中，当我们的线程在执行<code>n++</code>后，操作系统有可能会终端当前线程去执行另一个线程。而另一个线程如果恰好也执行了<code>n++</code>，<code>x + 1 == n</code>就不为<code>true</code>了，所以结果也就不是预期的<code>0</code>了。这就是多线程编程中的<code>竞争条件</code>(也叫<code>竞争冒险</code>、<code>竞态条件</code>)</p><p>那么如果我们想让结果为<code>0</code>需要怎么做呢？这就需要C++中的<code>mutex</code>来保护循环中的代码，让程序中的三个线程在同一时间只有一个线程执行循环中的代码，来避免<code>竞争条件</code>。</p><h2 id="mutex类"><a href="#mutex类" class="headerlink" title="mutex类"></a>mutex类</h2><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><code>mutex</code>常被称作<code>互斥锁</code>，<code>互斥量</code>，位于<code>&lt;mutex&gt;</code>头文件中。mutex的用途就是对可能出现竞争条件的代码段(<em>临界区</em>)“加锁”。线程要进入临界区，首先要获取锁，如果成功获取锁，线程可以进入临界区执行代码。如果线程想要获取的锁已经被其他线程占用，则线程会<code>阻塞</code>，直至其他线程释放这个锁。</p><h3 id="创建mutex对象"><a href="#创建mutex对象" class="headerlink" title="创建mutex对象"></a>创建mutex对象</h3><p>mutex类只有一个<code>默认构造函数</code>，它会创建一个没有被加锁的mutex对象。mutex类<code>没有拷贝和移动构造函数</code>，所以mutex不能被<code>拷贝</code>或者<code>移动</code>。</p><h3 id="锁定mutex"><a href="#锁定mutex" class="headerlink" title="锁定mutex"></a>锁定mutex</h3><p>线程调用mutex对象的<code>lock</code>成员函数会尝试获取这个锁。如果这个mutex对象没有被其他线程占有，当前线程就会获取这个锁。如果这个mutex已经被其他线程占用，调用线程会被阻塞直到其他线程释放这个锁。</p><h3 id="释放mutex"><a href="#释放mutex" class="headerlink" title="释放mutex"></a>释放mutex</h3><p>当线程执行完<em>临界区</em>的代码后，应当释放锁以便让其他线程能够获取这个锁。释放mutex通过调用mutex对象的<code>unlock</code>成员函数。</p><h3 id="使用mutex的栗子"><a href="#使用mutex的栗子" class="headerlink" title="使用mutex的栗子"></a>使用mutex的栗子</h3><p>下面的代码利用mutex改写了上一节的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>mutex g_lock;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>    &#123;<br>        g_lock.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">int</span> x = n;<br>        n++;<br>        <span class="hljs-keyword">if</span> (x + <span class="hljs-number">1</span> == n)<br>        &#123;<br>            n--;<br>        &#125;<br>        g_lock.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">t3</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    t3.<span class="hljs-built_in">join</span>();<br><br>    cout &lt;&lt; n &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，每个线程在执行循环中的代码时都会获取<em>g_lock</em><br>在执行完这几行代码后再释放g_lock，所以同一时间只有一个线程进入临界区，所以不会产生竞争条件等问题，程序输出结果始终为0。</p><h3 id="尝试锁定mutex"><a href="#尝试锁定mutex" class="headerlink" title="尝试锁定mutex"></a>尝试锁定mutex</h3><p>mutex有一个成员函数<code>try_lock</code>，在线程调用该成员函数时，如果mutex没有被其他线程占用，调用线程就会获取该锁并返回<code>true</code>；如果该mutex已被其他线程占用，则该函数返回<code>false</code>，并不会想<code>lock</code>一样阻塞住。</p><h2 id="recursive-mutex"><a href="#recursive-mutex" class="headerlink" title="recursive_mutex"></a>recursive_mutex</h2><p>如果一个线程已经占有了mutex，那么它在尝试再次为这个mutex加锁时会产生未定义的行为，可能会产生<em>死锁</em>，也可能导致程序崩溃。</p><p>如果我们需要对一个互斥量重复加锁，可以使用<code>recursive_mutex</code>。<br>recursive_mutex的用法与mutex基本相同。<br>当线程在对一个已经持有的recursive_mutex加锁时(调用lock成员函数)，该recursive_mutex的计数会加1。当线程调用unlock时计数减1。直到计数为0时(<em>即加锁次数与解锁次数相同</em>)时释放这个recursive_mutex。</p><h2 id="timed-mutex"><a href="#timed-mutex" class="headerlink" title="timed_mutex"></a>timed_mutex</h2><p><code>timed_mutex</code>类除了提供<code>mutex</code>类的基本功能之外，还提供了定时的功能。该类添加了两个新的成员函数<code>try_lock_for</code>和<code>try_lock_until</code></p><h3 id="try-lock-for"><a href="#try-lock-for" class="headerlink" title="try_lock_for"></a>try_lock_for</h3><p><code>try_lock_for</code>的函数原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rep</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Period</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">try_lock_for</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time)</span></span>;<br></code></pre></td></tr></table></figure><p>当一个线程调用timed_mutex的try_lock_for时，如果该timed_mutex没有被其他线程占用，该线程会立即占有这个timed_mutex并返回<code>true</code>。<br>如果该timed_mutex已经被其他线程占有，调用线程会阻塞，直到其他线程解锁了该timed_mutex(返回<code>true</code>)或超出指定的时间段<code>rel_time</code>(返回<code>false</code>)。</p><h3 id="try-lock-until"><a href="#try-lock-until" class="headerlink" title="try_lock_until"></a>try_lock_until</h3><p><code>try_lock_until</code>的函数原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Duration</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">try_lock_until</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)</span></span>;<br></code></pre></td></tr></table></figure><p>当一个线程调用timed_mutex的try_lock_until时，如果该timed_mutex没有被其他线程占用，该线程会立即占有这个timed_mutex并返回<code>true</code>。<br>如果该timed_mutex已经被其他线程占有，调用线程会阻塞，直到其他线程解锁了该timed_mutex(返回<code>true</code>)或到达了指定的时间点<code>abs_time</code>(返回<code>false</code>)。</p><h3 id="recursive-timed-mutex"><a href="#recursive-timed-mutex" class="headerlink" title="recursive_timed_mutex"></a>recursive_timed_mutex</h3><p>与mutex类似，timed_mutex也不支持<code>递归加锁</code>。如果需要可以递归加锁的timed_mutex，可以使用<code>recursive_timed_mutex</code>。<br>这个类的功能相当于<code>timed_mutex</code>+<code>recursive_mutex</code>，这里不再赘述，可以参考<a href="https://www.cplusplus.com/reference/">这个网站</a>。</p><h2 id="lock-guard类模板"><a href="#lock-guard类模板" class="headerlink" title="lock_guard类模板"></a>lock_guard类模板</h2><h3 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h3><p>如果一个线程在对mutex加锁后没有释放这个锁，其他线程就无法获取这个互斥锁。所以在一个线程在使用完mutex时，必须是释放这个mutex。</p><p>然而，人总是会犯错误的，程序员可能会忘记调用unlock释放mutex,尤其是在函数有多个出口的时候。为了解决这个问题，C++11为我们提供了一个<code>lock_guard类模板</code>来解决这个问题。</p><h3 id="创建lock-guard对象"><a href="#创建lock-guard对象" class="headerlink" title="创建lock_guard对象"></a>创建lock_guard对象</h3><p>在创建lock_guard对象时，我们需要向构造函数中传入一个mutex对象。lock_guard的构造函数会对这个mutex加锁。当lock_guard对象被析构时，析构函数会自动解锁mutex。这样，即使程序代码有多个出口，我们也能保证mutex被正确解锁。</p><p>lock_guard是一个类模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mutex</span>&gt;</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">lock_guard</span>;</span><br></code></pre></td></tr></table></figure><p>模板参数Mutex可以是<code>mutex</code>、<code>recursive_mutex</code>、<code>timed_mutex</code>、<code>recursive_timed_mutex</code>和<code>unique_lock</code>(<em>下文将会提到</em>)。</p><p>lock_guard的构造函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">lock_guard</span> <span class="hljs-params">(mutex_type&amp; m)</span></span>;<br></code></pre></td></tr></table></figure><p>我们可以用lock_guard改写之前的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>mutex g_lock;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>    &#123;<br>        <span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(g_lock)</span></span>;<br>        <span class="hljs-keyword">int</span> x = n;<br>        n++;<br>        <span class="hljs-keyword">if</span> (x + <span class="hljs-number">1</span> == n)<br>        &#123;<br>            n--;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">t3</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    t3.<span class="hljs-built_in">join</span>();<br><br>    cout &lt;&lt; n &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="adopt-lock-t"><a href="#adopt-lock-t" class="headerlink" title="adopt_lock_t"></a>adopt_lock_t</h3><p>lock_guard还有一个构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">lock_guard</span> (mutex_type&amp; m, <span class="hljs-keyword">adopt_lock_t</span> tag);<br></code></pre></td></tr></table></figure><p>向构造函数中传入<code>adopt_lock_t</code>对象可以防止lock_guard构造函数对mutex加锁。这样，我们可以自行对mutex加锁，然后让lock_guard对象代替我们释放锁。<code>adopt_lock_t</code>只是起到了让编译器选定特定构造函数的作用。</p><p>在<code>&lt;mutex&gt;</code>头文件中预定义了一个adopt_lock_t对象<code>adopt_lock</code>可以直接使用。</p><h2 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h2><p>C++提供了<code>unique_lock</code>类模板来灵活地管理互斥锁。它比<code>lock_guard</code>提供了更多的灵活性，但是比lock_guard占用更多的可空间并且性能也会相对慢一些。</p><p>C++11为unique_lock提供了很多构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">unique_lock</span>() <span class="hljs-keyword">noexcept</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">unique_lock</span> <span class="hljs-params">(mutex_type&amp; m)</span></span>;<br><br><span class="hljs-built_in">unique_lock</span> (mutex_type&amp; m, <span class="hljs-keyword">try_to_lock_t</span> tag);<br><br><span class="hljs-built_in">unique_lock</span> (mutex_type&amp; m, <span class="hljs-keyword">defer_lock_t</span> tag) <span class="hljs-keyword">noexcept</span>;<br><br><span class="hljs-built_in">unique_lock</span> (mutex_type&amp; m, <span class="hljs-keyword">adopt_lock_t</span> tag);<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rep</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Period</span>&gt;</span><br><span class="hljs-built_in">unique_lock</span> (mutex_type&amp; m, <span class="hljs-keyword">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time);<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Duration</span>&gt;</span><br><span class="hljs-built_in">unique_lock</span> (mutex_type&amp; m, <span class="hljs-keyword">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time);<br><br><span class="hljs-built_in">unique_lock</span> (<span class="hljs-keyword">const</span> unique_lock&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-built_in">unique_lock</span> (unique_lock&amp;&amp; x);<br></code></pre></td></tr></table></figure><p>通常我们会向unique_lock的构造函数传入一个互斥锁对象(<em>mutex</em>、<em>recursive_mutex</em>、<em>timed_mutex</em>、<em>recursive_timed_mutex</em>)，让unique来管理这个锁。此外，还可以传入额外的参数来控制unique_lock的构造函数的行为。例如，传入前面提到的<code>adopt_lock_t</code>对象可以让unique_lock来管理已经被当前线程占有的互斥锁，传入<code>try_to_lock_t</code>对象让unique_lock尝试获取锁(可以用unique_lock的<code>owns_lock</code>判断是否成功获取锁)。传入<code>defer_lock_t</code>对象可以让unique_lock先不获取锁，在之后由程序员自行加锁。当unique_lock被析构时，如果它已经拥有它管理的锁，它可以自动释放该锁。另外，unique_lock还提供了<code>try_lock_for</code>和<code>try_lock_until</code>两个成员函数，这两个函数与<code>timed_mutex</code>用法类似，不再赘述。</p><p>unique_lock只有移动构造函数，没有拷贝构造函数，这意味着它只可以被移动，不可以被复制。当unique_lock被移动时，它对锁的拥有状态也相应移动，被移动的对象恢复默认构造状态。</p><p>详细的unique_lock的API可以参考<a href="https://www.cplusplus.com/reference/mutex/unique_lock/">这个</a>。</p><h2 id="call-once"><a href="#call-once" class="headerlink" title="call_once"></a>call_once</h2><p>读者不妨想一下，在一个多线程环境中，如何让一个函数只会被调用一次？</p><p>一个很自然的想法是可以使用一个变量<code>flag</code>，将这个变量初始化为<code>false</code>，当一个线程需要调用这个函数时，先检测<code>flag</code>的值。如果<code>flag</code>为<code>false</code>，则将<code>flag</code>设置为<code>true</code>，然后调用该函数；如果<code>flag</code>的值为<code>true</code>，说明这个函数已经被调用过了，那么这个线程就不需要调用这个函数了。为了避免<code>竞争条件</code>，我们可以用<code>mutex</code>将临界区保护起来。</p><p>然而，在这种设计中，每个线程都必须获取互斥锁，造成了线程的序列化，影响了程序的性能。C++为我们提供了一个工具<code>call_once</code>，它保证一个函数只会被调用一次，同时还保证了较好的性能。</p><p><code>call_once</code>的函数原型如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fn</span>, <span class="hljs-title">class</span>... <span class="hljs-title">Args</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">call_once</span> <span class="hljs-params">(once_flag&amp; flag, Fn&amp;&amp; fn, Args&amp;&amp;... args)</span></span>;<br></code></pre></td></tr></table></figure><p><code>once_flag</code>是一个用于标识函数调用的类，它的对象可以被默认构造。</p><p>举个栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>once_flag flag;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">once</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;once被调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">call_once</span>(flag, once);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">t3</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    t3.<span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上例子中，<code>&quot;once被调用&quot;</code>只会被输出一次，而不是三次。</p><h2 id="一次锁定多个mutex"><a href="#一次锁定多个mutex" class="headerlink" title="一次锁定多个mutex"></a>一次锁定多个mutex</h2><p>C++的<code>&lt;mutex&gt;</code>头文件中提供了两个可用于同时锁定多个互斥量的函数：<code>std::try_lock</code>和<code>std::lock</code>。这两个函数都会保证不产生死锁。</p><h3 id="std-try-lock"><a href="#std-try-lock" class="headerlink" title="std::try_lock"></a>std::try_lock</h3><p>std::try_lock的函数原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mutex1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Mutex2</span>, <span class="hljs-title">class</span>... <span class="hljs-title">Mutexes</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">try_lock</span> <span class="hljs-params">(Mutex1&amp; a, Mutex2&amp; b, Mutexes&amp;... cde)</span></span>;<br></code></pre></td></tr></table></figure><p><code>std::try_lock</code>依次调用每个参数的<code>try_lock</code>成员函数尝试对每个互斥量加锁，如果try_lock成员函数返回<code>false</code>，std::try_lock会释放已经持有的锁并返回<code>false</code>，如果所有互斥量都成功加锁，std::try_lock会返回<code>true</code>。</p><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mutex1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Mutex2</span>, <span class="hljs-title">class</span>... <span class="hljs-title">Mutexes</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span> <span class="hljs-params">(Mutex1&amp; a, Mutex2&amp; b, Mutexes&amp;... cde)</span></span>;<br></code></pre></td></tr></table></figure><p><code>std::lock</code>会尝试对所有的互斥量尝试加锁，如果加锁失败，它会释放所有已拥有的锁并重新尝试加锁，直到获取所有的锁之后返回。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.cplusplus.com/reference/mutex/">&lt;mutex&gt; - C++ Reference</a></li><li>《C++并发编程实战》</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>线程</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCC编译器常用优化参数</title>
    <link href="/2021/08/11/blog/C/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E5%8F%82%E6%95%B0/"/>
    <url>/2021/08/11/blog/C/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="GCC编译器常用优化参数"><a href="#GCC编译器常用优化参数" class="headerlink" title="GCC编译器常用优化参数"></a>GCC编译器常用优化参数</h1><blockquote><p>-O0: 不进行优化(默认选项)。</p><p>-O1、-O2、-O3: 随着数字变大，代码的优化程度逐渐提高。</p><p>-Os：优化尺寸。</p><p>-Ofast：启用所有-O3优化，无视严格的标准合规性。</p><p>-Og：在 -O1 的基础上，去掉了影响调试的优化。</p><p>-O：等价于-O1。</p></blockquote><p>如果使用多个 -O 选项，以最后一个选项为准。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://cloud.tencent.com/developer/article/1524971">GCC 优化级别</a></li><li><a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options">3.11 Options That Control Optimization</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>GCC</tag>
      
      <tag>编译器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++多线程编程（一）：使用thread类</title>
    <link href="/2021/08/10/blog/C++/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8thread%E7%B1%BB/"/>
    <url>/2021/08/10/blog/C++/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8thread%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="C-多线程编程（一）：使用thread类"><a href="#C-多线程编程（一）：使用thread类" class="headerlink" title="C++多线程编程（一）：使用thread类"></a>C++多线程编程（一）：使用thread类</h1><p>千呼万唤始出来！在C++11这一核弹级更新中加入了对多线程编程的支持，从此程序猿们就可以在不借助Boost等第三方库（<em>或者自己造轮子</em>）情况下方便地编写跨平台的多线程程序。我将在<code>《C++多线程编程》</code>这一系列博客中介绍C++11中多线程编程的相关知识。让我们先从thread类开始。</p><h2 id="thread类的功能"><a href="#thread类的功能" class="headerlink" title="thread类的功能"></a>thread类的功能</h2><p><code>thread类</code>是C++中表示<code>执行线程</code>的类，位于头文件<code>&lt;thread&gt;</code>中。我们创建一个thread对象就会立即执行一个对应的线程。通过thread类的成员函数，我们可以标识线程或对线程进行控制。</p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p>我们构造一个thread类的对象，就会立即执行一个与该thread对象对应的线程。通常我们会向thread类的构造函数传递一个<code>可调用对象</code>，新创建的线程就会执行这个可调用对象。<strong>可调用对象</strong>可以是<code>函数</code>、<code>函数指针</code>、<code>lambda表达式</code>或<code>function对象</code>。</p><p><strong>栗子：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*func_ptr)(<span class="hljs-keyword">void</span>) = func;<br>    function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">void</span>)&gt; func_obj = func;<br><br>    <span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">t2</span><span class="hljs-params">(func_ptr)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">t3</span><span class="hljs-params">(func_obj)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">t4</span><span class="hljs-params">([]</span></span><br><span class="hljs-params"><span class="hljs-function">              &#123; cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl; &#125;)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    t3.<span class="hljs-built_in">join</span>();<br>    t4.<span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，我们分别向thread类的构造函数传递了<strong>函数</strong>、<strong>函数指针</strong>、<strong>function对象</strong>和<strong>lambda表达式</strong>。创建出的四个线程都是向标准输出中输出**”hello world”**。那么thread对象的join成员函数是干什么呢？我将在“连接线程”这一节中向大家介绍。</p><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>既然thread类的构造函数可以接受一个可调用对象，那么可不可以想这个可调用参数<code>传递参数</code>呢？当然可以！如果我们想要想可调用对象传递参数，只需要将参数和可调用对象一并放入thread类的构造函数的参数列表中即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n1, <span class="hljs-keyword">int</span> n2)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; n1 &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; n2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; n1 + n2 &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">(add, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">t2</span><span class="hljs-params">([](<span class="hljs-keyword">int</span> n1, <span class="hljs-keyword">int</span> n2)</span></span><br><span class="hljs-params"><span class="hljs-function">              &#123; cout &lt;&lt; n1 &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; n2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; n1 + n2 &lt;&lt; endl; &#125;,</span></span><br><span class="hljs-params"><span class="hljs-function">              <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上的例子中，我们向thread类传入可调用对象和两个参数，可调用对象在执行时输出两个参数的和。</p><p>thread类的构造函数可以接受任意多的额外的参数，只需要传入的参数与可调用对象的参数列表一一对应即可。</p><h2 id="连接线程与分离线程"><a href="#连接线程与分离线程" class="headerlink" title="连接线程与分离线程"></a>连接线程与分离线程</h2><h3 id="连接线程"><a href="#连接线程" class="headerlink" title="连接线程"></a>连接线程</h3><p>在上一节的两个例子中，我们均调用了thread对象的<code>join成员函数</code>。join成员函数的作用是<code>等待线程完成</code>。请读者试想一下，假如我们在main函数中创建了一个线程对象A，线程A在被创建之后执行了一个非常耗时的任务。而main函数(<em>主线程</em>)在创建完线程A后执行return 0，整个进程就会被终止，此时线程A即使没有执行完成也会被终止，程序的只想结果往往就不是我们所期望的了。所以我们需要在主线程中调用join成员函数来等线程执行完成，这个操作也叫<code>连接线程</code>。当我们调用join时，如果线程尚未执行完成，就对阻塞调用join的线程直至线程执行完成。若干在调用join时线程已经执行完成，则join会立即返回，不会阻塞调用线程。</p><h3 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h3><p>如果我们不需要等待线程完成，可以调用thread对象的<code>detach</code>成员函数分离线程，之后这个线程就可以独立运行，不需要我们调用join等待它执行完成。分离线程通常用于执行一些后台任务的线程。</p><h3 id="可连接线程与不可连接线程"><a href="#可连接线程与不可连接线程" class="headerlink" title="可连接线程与不可连接线程"></a>可连接线程与不可连接线程</h3><p>如果一个thread对象是符合以下任意一种情况，它将是不可连接的：</p><blockquote><ol><li>默认构造的thread对象。</li><li>该thread对象已经被移动到另一个thread对象。</li><li>thread对象已经被连接或分离。</li></ol></blockquote><p>不能对不可连接的线程对象调用join。</p><h3 id="线程与thread类析构函数"><a href="#线程与thread类析构函数" class="headerlink" title="线程与thread类析构函数"></a>线程与thread类析构函数</h3><p>当一个thread对象被析构时，如果该thread对象对应的线程还没有执行完成，线程<code>仍然会继续执行</code>，不会因为thread对象被析构而停止执行。</p><p>如果一个线程是可连接的，则必须在thread对象被析构前调用join，否则析构函数会调用<code>std::terminate</code>终止程序。</p><h2 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h2><h3 id="thread-id类"><a href="#thread-id类" class="headerlink" title="thread::id类"></a>thread::id类</h3><p>在C++中用<code>thread::id类</code>来标识线程。对于<code>可连接线程</code>，可以通过<code>get_id</code>成员函数获得标识该thread对象的thread::id对象，每个thread对象的id唯一。对于<code>不可连接线程</code>，调用get_id会返回<code>默认构造的thread_id对象</code>，所有不可连接线程的id相等。</p><p>thread::id类重载了一下运算符用于thread::id对象的相等性比较：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>== (thread::id lhs, thread::id rhs) <span class="hljs-keyword">noexcept</span>;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!= (thread::id lhs, thread::id rhs) <span class="hljs-keyword">noexcept</span>;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (thread::id lhs, thread::id rhs) <span class="hljs-keyword">noexcept</span>;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;= (thread::id lhs, thread::id rhs) <span class="hljs-keyword">noexcept</span>;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt; (thread::id lhs, thread::id rhs) <span class="hljs-keyword">noexcept</span>;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;= (thread::id lhs, thread::id rhs) <span class="hljs-keyword">noexcept</span>;<br></code></pre></td></tr></table></figure><p>thread::id还重载了<code>&lt;&lt;运算符</code>用于向输出流中输出thread::id：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">charT</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">traits</span>&gt;</span><br>basic_ostream&lt;chasrT, traits&gt;&amp; <span class="hljs-keyword">operator</span>&lt;&lt; (basic_ostream&lt;charT,traits&gt;&amp; os, thread::id id);<br></code></pre></td></tr></table></figure><h3 id="获取当前线程的thread-id"><a href="#获取当前线程的thread-id" class="headerlink" title="获取当前线程的thread::id"></a>获取当前线程的thread::id</h3><p>通过调用<code>命名空间this_thread</code>中的<code>静态函数get_id</code>可以获得当前线程的线程id。</p><h3 id="获取原生线程句柄"><a href="#获取原生线程句柄" class="headerlink" title="获取原生线程句柄"></a>获取原生线程句柄</h3><p>通过调用thread对象的<code>native_handle</code>成员函数可以获得平台相关的原生线程句柄，原生线程句柄类型<code>thread::native_handle_type</code>与实现有关，可能会影响程序的可移植性，不建议在一般情况下使用。</p><h2 id="转移线程对象的所有权"><a href="#转移线程对象的所有权" class="headerlink" title="转移线程对象的所有权"></a>转移线程对象的所有权</h2><p>thread类的<code>拷贝构造函数</code>被定义为删除的，所以thread对象只可以被移动，不能被拷贝。</p><h2 id="this-thread的命名空间"><a href="#this-thread的命名空间" class="headerlink" title="this_thread的命名空间"></a>this_thread的命名空间</h2><p>this_thread命名空间提供了访问当前线程的一些函数，除了上文提到的<code>get_id</code>外，还有<code>yield</code>、<code>sleep_until</code>和<code>sleep_for</code>。</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>调用yield函数可以让出当前线程，让操作系统调度同一进程的其他线程。</p><h3 id="sleep-until"><a href="#sleep-until" class="headerlink" title="sleep_until"></a>sleep_until</h3><p><code>sleep_until</code>可以阻塞调用线程直至某个时间点。函数原型为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Duration</span>&gt;</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sleep_until</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="sleep-for"><a href="#sleep-for" class="headerlink" title="sleep_for"></a>sleep_for</h3><p><code>sleep_for</code>可以在制定的时间跨度内阻塞线程的执行。函数原型为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rep</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Period</span>&gt;</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sleep_for</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="检测硬件并发数"><a href="#检测硬件并发数" class="headerlink" title="检测硬件并发数"></a>检测硬件并发数</h2><p>通过调用thread类的<code>hardware_concurrency静态函数</code>可以获得硬件线程的上下文数量，也就是硬件可以真正同时执行的线程的数目，返回值通常为<code>逻辑CPU的数目</code>。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li>《C++并发编程实战》</li><li><a href="https://www.cplusplus.com/reference/thread/thread/">thread - C++ Reference</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>线程</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言宏函数重载</title>
    <link href="/2021/08/09/blog/C/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    <url>/2021/08/09/blog/C/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言宏函数重载"><a href="#C语言宏函数重载" class="headerlink" title="C语言宏函数重载"></a>C语言宏函数重载</h1><p>今天在一篇博客中学到了C语言宏函数重载的方法，在此记录一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SUM1(A) (A)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SUM2(A, B) ((A) + (B))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SUM3(A, B, C) ((A) + (B) + (C))</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GET_MACRO(_1, _2, _3, NAME, ...) NAME</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SUM(...)                             \</span><br><span class="hljs-meta">    GET_MACRO(__VA_ARGS__, SUM3, SUM2, SUM1) \</span><br><span class="hljs-meta">    (__VA_ARGS__)</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, SUM(<span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, SUM(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, SUM(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>宏函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令学习之lsof</title>
    <link href="/2021/08/03/blog/Linux/Linux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E4%B9%8Blsof/"/>
    <url>/2021/08/03/blog/Linux/Linux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E4%B9%8Blsof/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux命令学习之lsof"><a href="#Linux命令学习之lsof" class="headerlink" title="Linux命令学习之lsof"></a>Linux命令学习之lsof</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>lsof</code>是一个用于列出进程<code>打开的文件</code>的命令。由于在Linux系统上“一切皆文件”，lsof不仅可以获取进程打开的普通文件的列表，还可以获取进程打开的目录、块特殊文件、字符特殊文件、套接字等各种信息。</p><h2 id="lsof的安装"><a href="#lsof的安装" class="headerlink" title="lsof的安装"></a>lsof的安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 在ArchLinux上通过pacman安装。</span><br>sudo pacman -S lsof<br></code></pre></td></tr></table></figure><h2 id="lsof输出的信息"><a href="#lsof输出的信息" class="headerlink" title="lsof输出的信息"></a>lsof输出的信息</h2><p>我们打开nano文本编辑器，然后执行<code>lsof -c nano</code>，输出如下:</p><blockquote><p>\COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF      NODE NAME<br>nano    19027  lsh  cwd    DIR  259,9       60 134261379 /home/lsh/learn/c<br>nano    19027  lsh  rtd    DIR  259,8      224       128 /<br>nano    19027  lsh  txt    REG  259,8   352840  34708268 /usr/bin/nano<br>nano    19027  lsh  mem    REG  259,8  6198768 102247963 /usr/lib/locale/locale-archive<br>nano    19027  lsh  mem    REG  259,8   154040 100664178 /usr/lib/libpthread-2.33.so<br>nano    19027  lsh  mem    REG  259,8   100096 100665882 /usr/lib/libz.so.1.2.11<br>nano    19027  lsh  mem    REG  259,8    74448 100665990 /usr/lib/libbz2.so.1.0.8<br>nano    19027  lsh  mem    REG  259,8   157456 100665887 /usr/lib/liblzma.so.5.2.5<br>nano    19027  lsh  mem    REG  259,8  2150424 100664130 /usr/lib/libc-2.33.so<br>nano    19027  lsh  mem    REG  259,8   453688 100664712 /usr/lib/libncursesw.so.6.2<br>nano    19027  lsh  mem    REG  259,8   170080 100665234 /usr/lib/libmagic.so.1.0.0<br>nano    19027  lsh  mem    REG  259,8    54380  34753993 /usr/share/locale/zh_CN/LC_MESSAGES/nano.mo<br>nano    19027  lsh  mem    REG  259,8   221480 100664118 /usr/lib/ld-2.33.so<br>nano    19027  lsh    0u   CHR  136,2      0t0         5 /dev/pts/2<br>nano    19027  lsh    1u   CHR  136,2      0t0         5 /dev/pts/2<br>nano    19027  lsh    2u   CHR  136,2      0t0         5 /dev/pts/2<br>nano    19146  lsh  cwd    DIR  259,8     8192 100663426 /etc<br>nano    19146  lsh  rtd    DIR  259,8      224       128 /<br>nano    19146  lsh  txt    REG  259,8   352840  34708268 /usr/bin/nano<br>nano    19146  lsh  mem    REG  259,8  6198768 102247963 /usr/lib/locale/locale-archive<br>nano    19146  lsh  mem    REG  259,8   154040 100664178 /usr/lib/libpthread-2.33.so<br>nano    19146  lsh  mem    REG  259,8   100096 100665882 /usr/lib/libz.so.1.2.11<br>nano    19146  lsh  mem    REG  259,8    74448 100665990 /usr/lib/libbz2.so.1.0.8<br>nano    19146  lsh  mem    REG  259,8   157456 100665887 /usr/lib/liblzma.so.5.2.5<br>nano    19146  lsh  mem    REG  259,8  2150424 100664130 /usr/lib/libc-2.33.so<br>nano    19146  lsh  mem    REG  259,8   453688 100664712 /usr/lib/libncursesw.so.6.2<br>nano    19146  lsh  mem    REG  259,8   170080 100665234 /usr/lib/libmagic.so.1.0.0<br>nano    19146  lsh  mem    REG  259,8    54380  34753993 /usr/share/locale/zh_CN/LC_MESSAGES/nano.mo<br>nano    19146  lsh  mem    REG  259,8   221480 100664118 /usr/lib/ld-2.33.so<br>nano    19146  lsh    0u   CHR  136,2      0t0         5 /dev/pts/2<br>nano    19146  lsh    1u   CHR  136,2      0t0         5 /dev/pts/2<br>nano    19146  lsh    2u   CHR  136,2      0t0         5 /dev/pts/2</p></blockquote><p>可以看到lsof输出许多列的信息，各列信息的含义如下:</p><p>COMMAND: 执行该进程的可执行文件的名称<br>PID: 进程的进程号<br>USER: 进程的所有者<br>FD: 文件的文件描述符，可能有以下取值:</p><blockquote><p>txt: 该文件是程序代码<br>mem: 内存映射文件<br>rtd: 根目录<br>cwd: 当前工作目录<br>打开文件的文件描述符，r表示读取访问，w表示写访问，u表示读写访问。<br>TYPE: 文件的类型<br>DEVICE: 设备号<br>SIZE/OFF: 文件的大小或偏移量<br>NODE: 文件的i-node号<br>NAME: 文件的绝对路径</p></blockquote><h2 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h2><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">没有选项</td><td align="center">如果lsof不加任何选项，将列出所有进程的打开文件</td></tr><tr><td align="center">-h</td><td align="center">列出帮助信息</td></tr><tr><td align="center">-c COMMAND</td><td align="center">显示进程名称以COMMAND开头的进程信息</td></tr><tr><td align="center">-g GID</td><td align="center">列出组ID为GID的进程</td></tr><tr><td align="center">-p PID</td><td align="center">列出进程号为PID的进程</td></tr><tr><td align="center">-d FD</td><td align="center">列出文件描述符为FD的文件</td></tr><tr><td align="center">+d DIR</td><td align="center">列出目录被打开的进程</td></tr><tr><td align="center">+D DIR</td><td align="center">递归列出目录下被打开的文件</td></tr><tr><td align="center">-u UID</td><td align="center">列出所有者ID为UID的进程</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://man7.org/linux/man-pages/man8/lsof.8.html">lsof(8) — Linux manual page</a></li><li><a href="https://www.cnblogs.com/peida/archive/2013/02/26/2932972.html">每天一个linux命令（51）:lsof命令</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux生成UUID</title>
    <link href="/2021/07/26/blog/Linux/Linux%E7%94%9F%E6%88%90UUID/"/>
    <url>/2021/07/26/blog/Linux/Linux%E7%94%9F%E6%88%90UUID/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux生成UUID"><a href="#Linux生成UUID" class="headerlink" title="Linux生成UUID"></a>Linux生成UUID</h2><p>在<code>/proc/sys/kernel/random/uuid</code>处有一个特殊的文件，每次读取这个文件可以生成一个<code>UUID</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /proc/sys/kernel/random/uuid<br><span class="hljs-meta">#</span><span class="bash"> 输出为0353511c-1afa-4b37-9a26-cd7ad3ebefc6</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>daemon_init的实现</title>
    <link href="/2021/06/04/blog/Linux/daemon_init%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/06/04/blog/Linux/daemon_init%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="daemon-init的实现"><a href="#daemon-init的实现" class="headerlink" title="daemon_init的实现"></a>daemon_init的实现</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p><code>守护进程(Daemon)</code>是一种长期执行特定任务的进程，在编写某些程序（例如Web服务器）时经常使用到守护进程。在<code>Linux</code>中，需要根据一些约定将普通进程转换为守护进程。每次我们想要使用守护进程时都要进行繁琐的转换，很不方便。所以博主就实现了一个名为<code>daemon_init</code>的函数，把这些转换步骤都“包装”起来。当我们想要将一个普通进程转换为守护进程时，只需要调用这个函数就行了。</p><h2 id="普通进程转换成守护进程的步骤"><a href="#普通进程转换成守护进程的步骤" class="headerlink" title="普通进程转换成守护进程的步骤"></a>普通进程转换成守护进程的步骤</h2><ol><li>执行<code>fork()</code>，父进程退出，子进程继续执行。<blockquote><ul><li><p>让Shell以为程序已经执行完成。</p></li><li><p>确保子进程不是进程组的首进程。</p></li></ul></blockquote></li><li>子进程调用<code>setsid()</code>开启一个新会话并释放它与控制终端的所有关联关系。</li><li>再执行一次<code>fork()</code>，确保子进程不会成为会话组长。</li><li>清除进程的<code>umask</code>。</li><li>修改进程的当前目录为<code>根目录</code>，防止文件系统无法卸载。</li><li>关闭父进程的所有打开的文件描述符。</li><li>将文件描述符<code>0</code>，<code>1</code>和<code>2</code>指向<code>/dev/null</code>。</li></ol><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DAEMON_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DAEMON_H</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DAEMON_RESERVE_UMASK 1     <span class="hljs-comment">// 不清除umask。</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DAEMON_NO_CHDIR 2          <span class="hljs-comment">// 不改变工作目录。</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DAEMON_NO_CLOSE_FILES 4    <span class="hljs-comment">// 不关闭文件描述符。</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DAEMON_NO_REOPEN_STD_FDS 8 <span class="hljs-comment">// 不重新打开标准文件描述符。</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 将进程转换成守护进程。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param flags 对转换过程进行控制的标志。</span><br><span class="hljs-comment"> * @return int 若成功，返回0；若出错，返回-1。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">daemon_init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> flags)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// DAEMON_H</span></span><br></code></pre></td></tr></table></figure><p>之所以要有一个<code>flags</code>参数，是因为对转换过程进行控制。例如，有些守护进程不需要关闭所有文件描述符，则flags就可以设置为<code>DAEMON_NO_CLOSE_FILES</code>。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">daemon_init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建子进程，退出父进程。</span><br><span class="hljs-keyword">switch</span> (fork())<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 创建一个新会话。</span><br>    <span class="hljs-keyword">if</span> (setsid() == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 创建子进程，退出父进程（第二次）。</span><br>    <span class="hljs-keyword">switch</span> (fork())<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 清除进程的umask。</span><br>    <span class="hljs-keyword">if</span> (!(flags &amp; DAEMON_RESERVE_UMASK))<br>    &#123;<br>        umask(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 改变工作目录为根目录。</span><br>    <span class="hljs-keyword">if</span> (!(flags &amp; DAEMON_NO_CHDIR))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (chdir(<span class="hljs-string">&quot;/&quot;</span>))<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭所有文件描述符。</span><br>    <span class="hljs-keyword">if</span> (!(flags &amp; DAEMON_NO_CLOSE_FILES))<br>    &#123;<br>        <span class="hljs-keyword">int</span> max_fd = sysconf(_SC_OPEN_MAX);<br>        <span class="hljs-keyword">if</span> (max_fd == <span class="hljs-number">-1</span>)<br>        &#123;<br>            max_fd = DAEMON_MAX_FD;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> fd = <span class="hljs-number">0</span>; fd &lt; max_fd; fd++)<br>        &#123;<br>            close(fd);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 重新打开标准文件描述符，使其指向/dev/null。</span><br>    <span class="hljs-keyword">if</span> (!(flags &amp; DAEMON_NO_REOPEN_STD_FDS))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (open(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDONLY) != STDIN_FILENO)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (open(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_WRONLY) != STDOUT_FILENO)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (open(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_WRONLY) != STDERR_FILENO)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li>《Linux/UNIX系统编程手册》</li><li>《UNIX环境高级编程》</li><li><a href="https://dlonng.com/posts/daemon">Linux高级编程-守护进程</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>Linux</tag>
      
      <tag>守护进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>getopt、getopt_long和getopt_long_only的用法</title>
    <link href="/2021/06/01/blog/C/getopt%E3%80%81getopt_long%E5%92%8Cgetopt_long_only%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2021/06/01/blog/C/getopt%E3%80%81getopt_long%E5%92%8Cgetopt_long_only%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="getopt、getopt-long和getopt-long-only的用法"><a href="#getopt、getopt-long和getopt-long-only的用法" class="headerlink" title="getopt、getopt_long和getopt_long_only的用法"></a>getopt、getopt_long和getopt_long_only的用法</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>前段时间博主曾写过一个Linux下的小项目叫<code>myls</code>，也就是实现了ls的基本功能。myls的命令行参数解析是由博主自己编码完成的，这可把博主给坑惨了！博主不久前查资料的时候看到了<code>getopt</code>、<code>getopt_long</code>和<code>getopt_long_only</code>这三个函数，发现这三个函数堪称命令行参数解析的“神器”！早知道有这样的工具，博主也不至于被命令行参数解析所困扰了。这么好的东西当然要分享给大家啦！所以博主写了这篇博客，也欢迎大佬指教！</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p><code>getopt</code>、<code>getopt_long</code>和<code>getopt_long_only</code>这三个函数是干啥的嘞？当然是用来<code>解析命令行参数</code>的！我们通过向这三个函数传入字符串或者结构体数组来指定我们所关心的命令行参数，然后就可以得到解析的结果了。</p><p><code>getopt</code>函数用于解析<code>单字符参数</code>，比如<code>ls</code>的参数<code>-l</code>、<code>-a</code>等。</p><p><code>getopt_long</code>函数和<code>getopt_long_only</code>函数既可以解析<code>单字符命令行参数</code>，又可以解析<code>多字符命令行参数</code>。</p><p>需要说明的是这三个函数只能在<code>Linux/UNIX</code>使用哦！</p><h2 id="getopt函数的用法"><a href="#getopt函数的用法" class="headerlink" title="getopt函数的用法"></a>getopt函数的用法</h2><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getopt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *optstring)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="getopt的三个参数"><a href="#getopt的三个参数" class="headerlink" title="getopt的三个参数"></a>getopt的三个参数</h3><p>getopt的<code>argc</code>和<code>argv</code>参数就是<code>main函数</code>的<code>argc</code>和<code>argv</code>参数。<code>optstring</code>参数指定了我们关心的命令行选项。例如，我们写的一个程序<code>hello</code>支持两个选项<code>-a</code>和<code>-b</code>，那么optstring就可以设置为<code>&quot;ab&quot;</code>。getopt还支持带参数的选项。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc helloworld.c -o helloworld<br></code></pre></td></tr></table></figure><p>如果读者使用过GCC编译器，应该知道<code>-o</code>后面的<code>helloworld</code>是二进制文件的路径。这里的helloworld就是-o选项的参数。如果我们写的程序<code>hello</code>还有一个选项<code>-c</code>需要一个参数，那么optstring就可以是<code>abc:</code>。也就是在<code>c</code>后面加上一个<code>冒号:</code>。如果我们在<code>c</code>的后面加上两个冒号，那么参数对于<code>-c</code>选项来说就是可选的。</p><h3 id="四个全局变量"><a href="#四个全局变量" class="headerlink" title="四个全局变量"></a>四个全局变量</h3><p>getopt函数会使用到如下4个全局变量：</p><ol><li><code>extern char *optarg</code><blockquote><p>optarg用来保存<code>选项的参数</code>。例如，optstring的值为<code>a:</code>，我们在终端中键入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hello -a hahaha<br></code></pre></td></tr></table></figure><p>getopt就会将<code>-a</code>选项的参数hahaha存储到optarg。</p></blockquote></li><li><code>extern int optind</code><blockquote><p>getopt会从前往后解析命令行参数，optind就是getopt已解析到的选项在<code>argv</code>的下标。</p></blockquote></li><li><code>extern int opterr</code><blockquote><p>当opterr为非零值时，getopt会将错误信息输出到<code>stderr</code>；当opterr为0时则不会输出。</p><p>opterr的默认值为<code>1</code>。</p></blockquote></li><li><code>extern int optopt</code><blockquote><p>optopt存储<code>解析出错的选项</code>。比如我们只关心<code>-a</code>、<code>-b</code>，但是传入了<code>-c</code>，则optopt会存储选项<code>c</code>。还有另一种情况就<code>-b</code>选项需要一个参数，而用户并没有为<code>-b</code>参数，那么getopt也会解析出错，并把optopt设置为<code>b</code>。</p></blockquote></li></ol><h3 id="getopt的返回值"><a href="#getopt的返回值" class="headerlink" title="getopt的返回值"></a>getopt的返回值</h3><p>当getopt解析到一个包含于<code>optstring</code>的选项时，会这个选项字符对应的<code>ASCII码</code>。例如解析到<code>-a</code>会返回<code>97</code>。如果解析出错，getopt会返回<code>?</code>的<code>ASCII码</code>。如果argv已经解析完成，返回<code>-1</code>。</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> c;<br>    <span class="hljs-keyword">while</span> ((c = getopt(argc, argv, <span class="hljs-string">&quot;ab:c::&quot;</span>)) != <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">switch</span> (c)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;选项a\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;选项b\n&quot;</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;选项b的参数是: %s\n&quot;</span>, optarg);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;选项c\n&quot;</span>);<br>            <span class="hljs-keyword">if</span> (optarg != <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;选项c的参数是: %s\n&quot;</span>, optarg);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;未知的选项: &#x27;%c&#x27;\n&quot;</span>, c);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = optind; i &lt; argc; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, argv[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的<code>getopt_test.c</code>中，我们在<code>optstring</code>设置了三个选项：不带参数<code>a</code>、带参数的<code>b</code>、以及带可选参数的<code>c</code>。然后用switch-case语句处理getopt的返回值。根据前面的叙述，读者应该能看懂这段代码。但是最后的一段for循环代码是干啥的呢？其实，getopt在解析命令行参数时，会<code>调整argv中命令行参数的顺序</code>。它会将每个选项及其参数放在argv的前面，将非选项放在最后。当所有的选项解析完后，<code>optind</code>就是<code>argv</code>中第一个<code>非选项</code>的下标。所以，这个for循环的用途就是输出命令行参数中所有的非选项。</p><p>下面编译一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc getopt_test.c -o getopt_test -std=gnu17 -Wall -Werror<br></code></pre></td></tr></table></figure><p>在上面的shell命令中，我们C标准设置为<code>gnu17</code>是因为<code>getopt</code>属于扩展的库函数，并非标准规定的函数。</p><p>然后运行几个样例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">./getopt_test -a -bhhh -chh<br><span class="hljs-meta">#</span><span class="bash"> 选项a</span><br><span class="hljs-meta">#</span><span class="bash"> 选项b</span><br><span class="hljs-meta">#</span><span class="bash"> 选项b的参数是: hhh</span><br><span class="hljs-meta">#</span><span class="bash"> 选项c</span><br><span class="hljs-meta">#</span><span class="bash"> 选项c的参数是: hh</span><br><br>./getopt_test -a aa -bhhh bb -chh ff<br><span class="hljs-meta">#</span><span class="bash"> 选项a</span><br><span class="hljs-meta">#</span><span class="bash"> 选项b</span><br><span class="hljs-meta">#</span><span class="bash"> 选项b的参数是: hhh</span><br><span class="hljs-meta">#</span><span class="bash"> 选项c</span><br><span class="hljs-meta">#</span><span class="bash"> 选项c的参数是: hh</span><br><span class="hljs-meta">#</span><span class="bash"> aa</span><br><span class="hljs-meta">#</span><span class="bash"> bb</span><br><span class="hljs-meta">#</span><span class="bash"> ff</span><br></code></pre></td></tr></table></figure><p>对于必须有参数的选项，例如<code>-b</code>，它的参数既可以与选项分开写，也可以写在一起。（<code>-bhhh</code>，<code>-b hhh</code>都是正确的）。对于有可选参数的选项，则必须将选项和参数写在一起。</p><h2 id="getopt-long的用法"><a href="#getopt-long的用法" class="headerlink" title="getopt_long的用法"></a>getopt_long的用法</h2><h3 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h3><p><code>getopt</code>函数用来解析<code>单字符命令行参数</code>，<code>getopt_long</code>函数则同时支持<code>单字符命令行参数</code>和<code>多字符命令行参数</code>。例如<code>ps --help</code>的help参数。</p><h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;getopt.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getopt_long</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *optstring, <span class="hljs-keyword">const</span> struct option *longopts, <span class="hljs-keyword">int</span> *longindex)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>getopt_long</code>的前三个参数与<code>getopt</code>的含义相同，此处不再赘述。我们来看后两个参数。</p><p><code>getopt_long</code>的第四个参数<code>longopts</code>是一个结构体数组。<code>struct option</code>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">option</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>    <span class="hljs-keyword">int</span> has_arg;<br>    <span class="hljs-keyword">int</span> *flag;<br>    <span class="hljs-keyword">int</span> val;<br>&#125;;<br></code></pre></td></tr></table></figure><p>每个结构体对应了一个长选项。其中，name是长选项的名称，例如<code>--help</code>选项的name就是<code>help</code>。<code>has_arg</code>指明这个长选项是否有参数：<code>0</code>表示没有参数，<code>1</code>表示需要参数，<code>2</code>表示可选参数，在<code>getopt.h</code>分别定义了<code>no_argument</code>、<code>required_argument</code>和<code>optional_argument</code>三个宏来表示has_arg的三种可能的值。</p><p><code>flag</code>和<code>val</code>的作用分两种情况：</p><ol><li>当flag为NULL时，如果getopt_long解析到了该长选项，则返回val。</li></ol><blockquote><p>前文中我曾提到，getopt返回选项字符对应的<code>ASCII码</code>。如果我们将长选项也对应一个val来返回，就可以将短选项和长选项联系在一起。</p></blockquote><ol start="2"><li>当flag不为NULL时，如果getopt_long解析到了该长选项，则将val存入flag指向的地址。</li></ol><blockquote><p>让flag指向一个int，就可以通过检查flag来知道有没有对应的长选项的。此时getopt_long返回<code>0</code>。</p></blockquote><p>getopt_long的最后一个参数用于返回长选项在longopts结构体数组中的索引值，用于调试，一般置为NULL。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>getopt_long的返回值与getopt类似，不同的是当某个长选项的flag为NULL时，会将对应的val返回。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>getopt_long的longopts是一个结构体数组。在C语言中，我们传递数组的常用方法是传入一个指向数组的指针以及这个<code>数组的长度</code>。而在getopt_long中，并没有传入getopt_long长度，那么getopt_long如何知道这个结构体的长度呢。答案是我们传入getopt_long的结构体数组的最后一个结构体的各字段必须都为0，这样getopt_long就知道这个结构体是这个数组的结尾了。这类似于C语言中的字符串，用<code>\0</code>表示字符串的终止。</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;getopt.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">option</span> <span class="hljs-title">options</span>[] =</span> &#123;&#123;<span class="hljs-string">&quot;help&quot;</span>, required_argument, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1000</span>&#125;,<br>                               &#123;<span class="hljs-string">&quot;version&quot;</span>, optional_argument, &amp;flag, <span class="hljs-number">2000</span>&#125;,<br>                               &#123;<span class="hljs-string">&quot;hello&quot;</span>, no_argument, <span class="hljs-literal">NULL</span>, <span class="hljs-number">3000</span>&#125;&#125;;<br>    <span class="hljs-keyword">while</span> ((c = getopt_long(argc, argv, <span class="hljs-string">&quot;ab:c::&quot;</span>, options, <span class="hljs-literal">NULL</span>)) != <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">switch</span> (c)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;选项a\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;选项b\n&quot;</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;选项b的参数为：%s\n&quot;</span>, optarg);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;选项c\n&quot;</span>);<br>            <span class="hljs-keyword">if</span> (optarg != <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;选项c的参数为：%s\n&quot;</span>, optarg);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">2000</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--version选项\n&quot;</span>);<br>                <span class="hljs-keyword">if</span> (optarg != <span class="hljs-literal">NULL</span>)<br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--version选项的参数为：%s\n&quot;</span>, optarg);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1000</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--help选项\n&quot;</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--help选项的参数为：%s\n&quot;</span>, optarg);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3000</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--hello选项\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;未知的选项：%s\n&quot;</span>, optarg);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = optind; i &lt; argc; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, argv[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码不是很复杂，博主就不详细解释了。但是需要注意的一点是，向<code>必须要有参数的长选项</code>传入参数的方法有两种：一种是将参数放在长选项的后面，例如<code>--help hhh</code>；另一种是使用<code>等号=</code>，例如，<code>--help=hhh</code>。而向<code>可选参数的长选项</code>传参数只有一种，也就是<code>使用等号=</code>。</p><h2 id="getopt-long-only的用法"><a href="#getopt-long-only的用法" class="headerlink" title="getopt_long_only的用法"></a>getopt_long_only的用法</h2><p><code>get_long_only</code>与<code>getopt_long</code>用法相似，不同的是<code>get_long_only</code>解析的长选项以一个连字符<code>-</code>开头，而<code>get_long</code>解析的长选项以两个连字符<code>--</code>开头。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://www.cnblogs.com/qingergege/p/5914218.html">Linux下getopt()函数的简单使用</a></p></li><li><p><a href="https://man7.org/linux/man-pages/man3/getopt.3.html">getopt(3) — Linux manual page</a></p></li><li><p><a href="https://blog.csdn.net/pengrui18/article/details/8078813">Linux编程里getopt_long_only函数用法详解</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
